{
  "version": 3,
  "sources": ["../../../node_modules/@open-wc/dedupe-mixin/src/dedupeMixin.js", "../../../node_modules/@lit/reactive-element/src/decorators/custom-element.ts", "../../../node_modules/@lit/reactive-element/src/decorators/property.ts", "../../../node_modules/@lit/reactive-element/src/decorators/state.ts", "../../../node_modules/@lit/reactive-element/src/decorators/base.ts", "../../../node_modules/@lit/reactive-element/src/decorators/query.ts", "../../../node_modules/@lit/reactive-element/src/decorators/query-all.ts", "../../../node_modules/@lit/reactive-element/src/decorators/query-assigned-nodes.ts", "../../../node_modules/ramda/es/internal/_isPlaceholder.js", "../../../node_modules/ramda/es/internal/_curry1.js", "../../../node_modules/ramda/es/internal/_curry2.js", "../../../node_modules/ramda/es/internal/_arity.js", "../../../node_modules/ramda/es/internal/_curryN.js", "../../../node_modules/ramda/es/curryN.js", "../../../node_modules/ramda/es/curry.js", "../../../node_modules/@pwrs/mixins/lib/propOr.ts", "../../../node_modules/@pwrs/mixins/lib/logic.ts", "../../../node_modules/bind-decorator/index.js", "../../../node_modules/@pwrs/mixins/fire/fire-mixin.ts", "../../../node_modules/@pwrs/mixins/lib/dom.ts", "../../../node_modules/@pwrs/mixins/lib/pointfree.ts", "../../../node_modules/@pwrs/mixins/select/select-mixin.ts", "../../../node_modules/@lit/reactive-element/src/css-tag.ts", "../../../node_modules/@lit/reactive-element/src/reactive-element.ts", "../../../node_modules/lit/node_modules/lit-html/src/lit-html.ts", "../../../node_modules/lit/node_modules/lit-element/src/lit-element.ts", "../../../private/rocket-plugin-code-tabs/components/button.css", "../../../private/rocket-plugin-code-tabs/components/tabs.css", "../../../private/rocket-plugin-code-tabs/components/tab.css", "../../../private/rocket-plugin-code-tabs/components/code-tabs.ts"],
  "sourcesContent": ["const appliedClassMixins = new WeakMap();\n\n/** Vefify if the Mixin was previously applyed\n * @private\n * @param {function} mixin      Mixin being applyed\n * @param {object} superClass   Class receiving the new mixin\n * @returns {boolean}\n */\nfunction wasMixinPreviouslyApplied(mixin, superClass) {\n  let klass = superClass;\n  while (klass) {\n    if (appliedClassMixins.get(klass) === mixin) {\n      return true;\n    }\n    klass = Object.getPrototypeOf(klass);\n  }\n  return false;\n}\n\n/** Apply each mixin in the chain to make sure they are not applied more than once to the final class.\n * @export\n * @param {function} mixin      Mixin to be applyed\n * @returns {object}            Mixed class with mixin applied\n */\nexport function dedupeMixin(mixin) {\n  return superClass => {\n    if (wasMixinPreviouslyApplied(mixin, superClass)) {\n      return superClass;\n    }\n    const mixedClass = mixin(superClass);\n    appliedClassMixins.set(mixedClass, mixin);\n    return mixedClass;\n  };\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport {Constructor, ClassDescriptor} from './base.js';\n\nconst legacyCustomElement = (\n  tagName: string,\n  clazz: Constructor<HTMLElement>\n) => {\n  window.customElements.define(tagName, clazz);\n  // Cast as any because TS doesn't recognize the return type as being a\n  // subtype of the decorated class when clazz is typed as\n  // `Constructor<HTMLElement>` for some reason.\n  // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n  // applied to elements however.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return clazz as any;\n};\n\nconst standardCustomElement = (\n  tagName: string,\n  descriptor: ClassDescriptor\n) => {\n  const {kind, elements} = descriptor;\n  return {\n    kind,\n    elements,\n    // This callback is called once the class is otherwise fully defined\n    finisher(clazz: Constructor<HTMLElement>) {\n      window.customElements.define(tagName, clazz);\n    },\n  };\n};\n\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```\n * @customElement('my-element')\n * class MyElement extends LitElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n * @category Decorator\n * @param tagName The tag name of the custom element to define.\n */\nexport const customElement = (tagName: string) => (\n  classOrDescriptor: Constructor<HTMLElement> | ClassDescriptor\n) =>\n  typeof classOrDescriptor === 'function'\n    ? legacyCustomElement(tagName, classOrDescriptor)\n    : standardCustomElement(tagName, classOrDescriptor);\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport {PropertyDeclaration, ReactiveElement} from '../reactive-element.js';\nimport {ClassElement} from './base.js';\n\nconst standardProperty = (\n  options: PropertyDeclaration,\n  element: ClassElement\n) => {\n  // When decorating an accessor, pass it through and add property metadata.\n  // Note, the `hasOwnProperty` check in `createProperty` ensures we don't\n  // stomp over the user's accessor.\n  if (\n    element.kind === 'method' &&\n    element.descriptor &&\n    !('value' in element.descriptor)\n  ) {\n    return {\n      ...element,\n      finisher(clazz: typeof ReactiveElement) {\n        clazz.createProperty(element.key, options);\n      },\n    };\n  } else {\n    // createProperty() takes care of defining the property, but we still\n    // must return some kind of descriptor, so return a descriptor for an\n    // unused prototype field. The finisher calls createProperty().\n    return {\n      kind: 'field',\n      key: Symbol(),\n      placement: 'own',\n      descriptor: {},\n      // store the original key so subsequent decorators have access to it.\n      originalKey: element.key,\n      // When @babel/plugin-proposal-decorators implements initializers,\n      // do this instead of the initializer below. See:\n      // https://github.com/babel/babel/issues/9260 extras: [\n      //   {\n      //     kind: 'initializer',\n      //     placement: 'own',\n      //     initializer: descriptor.initializer,\n      //   }\n      // ],\n      initializer(this: {[key: string]: unknown}) {\n        if (typeof element.initializer === 'function') {\n          this[element.key as string] = element.initializer.call(this);\n        }\n      },\n      finisher(clazz: typeof ReactiveElement) {\n        clazz.createProperty(element.key, options);\n      },\n    };\n  }\n};\n\nconst legacyProperty = (\n  options: PropertyDeclaration,\n  proto: Object,\n  name: PropertyKey\n) => {\n  (proto.constructor as typeof ReactiveElement).createProperty(name, options);\n};\n\n/**\n * A property decorator which creates a reactive property that reflects a\n * corresponding attribute value. When a decorated property is set\n * the element will update and render. A [[`PropertyDeclaration`]] may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the [[`state`]] decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the [[`state`]] decorator should be used. When needed,\n * state properties can be initialized via public properties to facilitate\n * complex interactions.\n *\n * @example\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function property(options?: PropertyDeclaration) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (protoOrDescriptor: Object | ClassElement, name?: PropertyKey): any =>\n    name !== undefined\n      ? legacyProperty(options!, protoOrDescriptor as Object, name)\n      : standardProperty(options!, protoOrDescriptor as ClassElement);\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport {property} from './property.js';\n\nexport interface InternalPropertyDeclaration<Type = unknown> {\n  /**\n   * A function that indicates if a property should be considered changed when\n   * it is set. The function should take the `newValue` and `oldValue` and\n   * return `true` if an update should be requested.\n   */\n  hasChanged?(value: Type, oldValue: Type): boolean;\n}\n\n/**\n * Declares a private or protected reactive property that still triggers\n * updates to the element when it changes. It does not reflect from the\n * corresponding attribute.\n *\n * Properties declared this way must not be used from HTML or HTML templating\n * systems, they're solely for properties internal to the element. These\n * properties may be renamed by optimization tools like closure compiler.\n * @category Decorator\n */\nexport function state(options?: InternalPropertyDeclaration) {\n  return property({\n    ...options,\n    state: true,\n    attribute: false,\n  });\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ReactiveElement} from '../reactive-element.js';\n\nexport type Constructor<T> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any[]): T;\n};\n\n// From the TC39 Decorators proposal\nexport interface ClassDescriptor {\n  kind: 'class';\n  elements: ClassElement[];\n  finisher?: <T>(clazz: Constructor<T>) => void | Constructor<T>;\n}\n\n// From the TC39 Decorators proposal\nexport interface ClassElement {\n  kind: 'field' | 'method';\n  key: PropertyKey;\n  placement: 'static' | 'prototype' | 'own';\n  initializer?: Function;\n  extras?: ClassElement[];\n  finisher?: <T>(clazz: Constructor<T>) => void | Constructor<T>;\n  descriptor?: PropertyDescriptor;\n}\n\nexport const legacyPrototypeMethod = (\n  descriptor: PropertyDescriptor,\n  proto: Object,\n  name: PropertyKey\n) => {\n  Object.defineProperty(proto, name, descriptor);\n};\n\nexport const standardPrototypeMethod = (\n  descriptor: PropertyDescriptor,\n  element: ClassElement\n) => ({\n  kind: 'method',\n  placement: 'prototype',\n  key: element.key,\n  descriptor,\n});\n\n/**\n * Helper for decorating a property that is compatible with both TypeScript\n * and Babel decorators. The optional `finisher` can be used to perform work on\n * the class. The optional `descriptor` should return a PropertyDescriptor\n * to install for the given property.\n *\n * @param finisher {function} Optional finisher method; receives the element\n * constructor and property key as arguments and has no return value.\n * @param descriptor {function} Optional descriptor method; receives the\n * property key as an argument and returns a property descriptor to define for\n * the given property.\n * @returns {ClassElement|void}\n */\nexport const decorateProperty = ({\n  finisher,\n  descriptor,\n}: {\n  finisher?:\n    | ((ctor: typeof ReactiveElement, property: PropertyKey) => void)\n    | null;\n  descriptor?: (property: PropertyKey) => PropertyDescriptor;\n}) => (\n  protoOrDescriptor: ReactiveElement | ClassElement,\n  name?: PropertyKey\n  // Note TypeScript requires the return type to be `void|any`\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): void | any => {\n  // TypeScript / Babel legacy mode\n  if (name !== undefined) {\n    const ctor = (protoOrDescriptor as ReactiveElement)\n      .constructor as typeof ReactiveElement;\n    if (descriptor !== undefined) {\n      Object.defineProperty(protoOrDescriptor, name, descriptor(name));\n    }\n    finisher?.(ctor, name!);\n    // Babel standard mode\n  } else {\n    // Note, the @property decorator saves `key` as `originalKey`\n    // so try to use it here.\n    const key =\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (protoOrDescriptor as any).originalKey ??\n      (protoOrDescriptor as ClassElement).key;\n    const info: ClassElement =\n      descriptor != undefined\n        ? {\n            kind: 'method',\n            placement: 'prototype',\n            key,\n            descriptor: descriptor((protoOrDescriptor as ClassElement).key),\n          }\n        : {...(protoOrDescriptor as ClassElement), key};\n    if (finisher != undefined) {\n      info.finisher = function <ReactiveElement>(\n        ctor: Constructor<ReactiveElement>\n      ) {\n        finisher((ctor as unknown) as typeof ReactiveElement, key);\n      };\n    }\n    return info;\n  }\n};\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport {ReactiveElement} from '../reactive-element.js';\nimport {decorateProperty} from './base.js';\n\n/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n * @param cache An optional boolean which when true performs the DOM query only\n *     once and caches the result.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * @example\n *\n * ```ts\n * class MyElement {\n *   @query('#first')\n *   first;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function query(selector: string, cache?: boolean) {\n  return decorateProperty({\n    descriptor: (name: PropertyKey) => {\n      const descriptor = {\n        get(this: ReactiveElement) {\n          return this.renderRoot?.querySelector(selector);\n        },\n        enumerable: true,\n        configurable: true,\n      };\n      if (cache) {\n        const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n        descriptor.get = function (this: ReactiveElement) {\n          if (\n            ((this as unknown) as {[key: string]: Element | null})[\n              key as string\n            ] === undefined\n          ) {\n            ((this as unknown) as {[key: string]: Element | null})[\n              key as string\n            ] = this.renderRoot?.querySelector(selector);\n          }\n          return ((this as unknown) as {[key: string]: Element | null})[\n            key as string\n          ];\n        };\n      }\n      return descriptor;\n    },\n  });\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport {ReactiveElement} from '../reactive-element.js';\nimport {decorateProperty} from './base.js';\n\n/**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\n *\n * @example\n * ```ts\n * class MyElement {\n *   @queryAll('div')\n *   divs;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function queryAll(selector: string) {\n  return decorateProperty({\n    descriptor: (_name: PropertyKey) => ({\n      get(this: ReactiveElement) {\n        return this.renderRoot?.querySelectorAll(selector);\n      },\n      enumerable: true,\n      configurable: true,\n    }),\n  });\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport {ReactiveElement} from '../reactive-element.js';\nimport {decorateProperty} from './base.js';\n\n// TODO(sorvell): Remove when https://github.com/webcomponents/polyfills/issues/397 is addressed.\n// x-browser support for matches\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst ElementProto = Element.prototype as any;\nconst legacyMatches =\n  ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;\n\n/**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedNodes` of the given named `slot`. Note, the type of\n * this property should be annotated as `NodeListOf<HTMLElement>`.\n *\n * @param slotName A string name of the slot.\n * @param flatten A boolean which when true flattens the assigned nodes,\n *     meaning any assigned nodes that are slot elements are replaced with their\n *     assigned nodes.\n * @param selector A string which filters the results to elements that match\n *     the given css selector.\n *\n * * @example\n * ```ts\n * class MyElement {\n *   @queryAssignedNodes('list', true, '.item')\n *   listItems;\n *\n *   render() {\n *     return html`\n *       <slot name=\"list\"></slot>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function queryAssignedNodes(\n  slotName = '',\n  flatten = false,\n  selector = ''\n) {\n  return decorateProperty({\n    descriptor: (_name: PropertyKey) => ({\n      get(this: ReactiveElement) {\n        const slotSelector = `slot${\n          slotName ? `[name=${slotName}]` : ':not([name])'\n        }`;\n        const slot = this.renderRoot?.querySelector(slotSelector);\n        let nodes = (slot as HTMLSlotElement)?.assignedNodes({flatten});\n        if (nodes && selector) {\n          nodes = nodes.filter(\n            (node) =>\n              node.nodeType === Node.ELEMENT_NODE &&\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              ((node as any).matches\n                ? (node as Element).matches(selector)\n                : legacyMatches.call(node as Element, selector))\n          );\n        }\n        return nodes;\n      },\n      enumerable: true,\n      configurable: true,\n    }),\n  });\n}\n", "export default function _isPlaceholder(a) {\n  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}", "import _isPlaceholder from \"./_isPlaceholder.js\";\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\nexport default function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}", "import _curry1 from \"./_curry1.js\";\nimport _isPlaceholder from \"./_isPlaceholder.js\";\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\nexport default function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}", "export default function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0:\n      return function () {\n        return fn.apply(this, arguments);\n      };\n\n    case 1:\n      return function (a0) {\n        return fn.apply(this, arguments);\n      };\n\n    case 2:\n      return function (a0, a1) {\n        return fn.apply(this, arguments);\n      };\n\n    case 3:\n      return function (a0, a1, a2) {\n        return fn.apply(this, arguments);\n      };\n\n    case 4:\n      return function (a0, a1, a2, a3) {\n        return fn.apply(this, arguments);\n      };\n\n    case 5:\n      return function (a0, a1, a2, a3, a4) {\n        return fn.apply(this, arguments);\n      };\n\n    case 6:\n      return function (a0, a1, a2, a3, a4, a5) {\n        return fn.apply(this, arguments);\n      };\n\n    case 7:\n      return function (a0, a1, a2, a3, a4, a5, a6) {\n        return fn.apply(this, arguments);\n      };\n\n    case 8:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn.apply(this, arguments);\n      };\n\n    case 9:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn.apply(this, arguments);\n      };\n\n    case 10:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn.apply(this, arguments);\n      };\n\n    default:\n      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n}", "import _arity from \"./_arity.js\";\nimport _isPlaceholder from \"./_isPlaceholder.js\";\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\nexport default function _curryN(length, received, fn) {\n  return function () {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n\n      combined[combinedIdx] = result;\n\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n\n      combinedIdx += 1;\n    }\n\n    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n  };\n}", "import _arity from \"./internal/_arity.js\";\nimport _curry1 from \"./internal/_curry1.js\";\nimport _curry2 from \"./internal/_curry2.js\";\nimport _curryN from \"./internal/_curryN.js\";\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      const sumArgs = (...args) => R.sum(args);\n *\n *      const curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      const f = curriedAddFourNumbers(1, 2);\n *      const g = f(3);\n *      g(4); //=> 10\n */\n\nvar curryN =\n/*#__PURE__*/\n_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n\n  return _arity(length, _curryN(length, [], fn));\n});\n\nexport default curryN;", "import _curry1 from \"./internal/_curry1.js\";\nimport curryN from \"./curryN.js\";\n/**\n * Returns a curried equivalent of the provided function. The curried function\n * has two unusual capabilities. First, its arguments needn't be provided one\n * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig (* -> a) -> (* -> a)\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curryN, R.partial\n * @example\n *\n *      const addFourNumbers = (a, b, c, d) => a + b + c + d;\n *\n *      const curriedAddFourNumbers = R.curry(addFourNumbers);\n *      const f = curriedAddFourNumbers(1, 2);\n *      const g = f(3);\n *      g(4); //=> 10\n */\n\nvar curry =\n/*#__PURE__*/\n_curry1(function curry(fn) {\n  return curryN(fn.length, fn);\n});\n\nexport default curry;", "import { curry } from \"ramda\";\n\nexport const propOr = curry(\n  <O, T extends object>(or: O, propName: string, object: T): T[keyof T] | O =>\n    (propName in object && object[propName] !== undefined) ? object[propName] : or\n);", "import { curry } from 'ramda';\n\ntype Predicate<T> = (x: T) => boolean;\n\nexport const and =\n  curry(<T>(p: Predicate<T>, q: Predicate<T>, x: T) => p(x) && q(x));\n\nexport const or =\n  curry(<T>(p: Predicate<T>, q: Predicate<T>, x: T) => p(x) || q(x));\n\nexport const not =\n  curry(<T>(p: Predicate<T>, x: T) => !p(x));", "const configurable = true;\nexport function bound(_, key, descriptor) {\n  if (typeof descriptor?.value !== 'function')\n    throw new TypeError(`Only methods can be decorated with @bound. <${key ?? _.name}> is not a method!`);\n  return {\n    configurable,\n    get() {\n      const value = descriptor.value.bind(this);\n      Object.defineProperty(this, key, { value, configurable, writable: true });\n      return value;\n    },\n  };\n}\nexport default bound;\n", "import type { Constructor, CustomElement } from \"../lib/constructor\";\nimport { dedupeMixin } from '@open-wc/dedupe-mixin'\n\nexport interface FireMixinElement extends CustomElement {\n  fire(type: string, detail?: any, init?: EventInit): boolean\n}\n\n/**\n * Mixin which adds `fire` method\n *\n * @param superclass the class to mix in to\n * @return  The mixed class\n */\nexport const FireMixin = dedupeMixin(\n  function FireMixin<TBase extends Constructor<CustomElement>>(superclass: TBase): TBase & Constructor<FireMixinElement> {\n    class FireMixinElement extends superclass {\n      /**\n       * Fires a CustomEvent with an optional supplied detail.\n       *\n       * Fired events do not bubble and are not composed by default,\n       * Pass an EventInit in the third argument to set `bubbles` or `composed`.\n       *\n       * @param  type   CustomEvent type\n       * @param  detail detail value\n       * @param  options options initializer\n       */\n      fire(type: string, detail?: any, init?: EventInit): boolean {\n        const { bubbles = false, composed = false } = init ?? {}\n        return this.dispatchEvent(new CustomEvent(type, { bubbles, composed, detail }));\n      }\n    };\n\n    return FireMixinElement;\n  });\n", "import { or } from \"./logic\";\n\nexport const matches = (selector: string) => (el: Element) =>\n  el.matches(selector);\n\nconst isFocused = matches(':focus');\n\nconst isActive = matches(':active');\n\n/** True when the element is focused or active */\nexport const isFocusedOrActive: (el: Element) => boolean =\n  or(isFocused, isActive);\n", "export const elem =\n  <T>(xs: T[]) => (x: T): boolean =>\n    Array.isArray(xs) ? xs.includes(x) : false;\n", "import type { PropertyValues, LitElement } from 'lit';\nimport { dedupeMixin } from '@open-wc/dedupe-mixin';\nimport { property, query } from 'lit/decorators.js';\n\nimport { propOr } from '../lib/propOr';\nimport { not } from '../lib/logic';\n\nimport bound from 'bind-decorator';\n\nimport { FireMixin, FireMixinElement } from '../fire/fire-mixin';\n\nimport { matches, isFocusedOrActive } from '../lib/dom';\nimport { elem } from '../lib/pointfree';\n\ntype SlotchangeEvent = Event & { target: HTMLSlotElement };\n\ntype Constructor<T = HTMLElement> = {\n  new (...args: any[]): T\n}\n\nexport interface Item extends HTMLElement {\n  itemIndex: number;\n}\n\nexport declare class SelectMixinElement extends LitElement {\n  static allowedChildren: string[]|RegExp;\n\n  itemsMutationObserver: MutationObserver;\n\n  _items: Item[];\n\n  _focusedIndex: number;\n\n  _focusedItem: Item;\n\n  previousSelectedItem: Item | Item[];\n\n  previousSelectedIndex: number | number[];\n\n  /**\n   * The selectable items\n   */\n  readonly items: Item[]\n\n  /**\n   * Whether multiple selections are allowed\n   */\n  multi: boolean;\n\n  /**\n   * The index of the focused item\n   */\n  readonly focusedIndex: number\n\n  /**\n   * The focused item\n   */\n  readonly focusedItem: Item\n\n  /**\n   * The boolean attribute on items which, when present, indicates that the item is selected.\n   */\n  attributeForSelected: string;\n\n  /**\n   * The currently selected item's index\n   */\n  selectedIndex: number | number[];\n\n  /**\n   * The currently selected Item\n   */\n  readonly selectedItem: Item|Item[];\n\n  /**\n   * Selected Item's Value\n   */\n  readonly value: unknown|unknown[]\n\n  /**\n   * Whether one of the items is the active element (i.e. focused)\n   */\n  readonly hasActiveItem: boolean;\n\n  /**\n   * The anonymous slot for list items\n   */\n  contentSlot: HTMLSlotElement;\n\n  /**\n   * Updates the read-only `selectedItem` and `selectedIndex` properties\n   * Updates the `value` property\n   * @param  selectedIndex selectedIndex\n   */\n  selectIndex(selectedIndex: number): void\n\n  /**\n   * Selects the next item in the list.\n   * Wraps around to first item from last.\n   */\n  selectNext(): void;\n\n  /**\n   * Selects the previous item in the list.\n   * Wraps around to last item from first.\n   */\n  selectPrevious(): void;\n\n  // PRIVATE METHODS\n\n  /**\n   * Updates the read-only `focusedIndex` property\n   * @param  focusedIndex focusedIndex\n   */\n  focusIndex(focusedIndex: number): void;\n\n  /**\n   * Focuses the next item in the list.\n   * Wraps around to first item from last.\n   */\n  focusNext(): void;\n\n  /**\n   * Focuses the previous item in the list.\n   * Wraps around to last item from first.\n   */\n  focusPrevious(): void;\n\n  setItemIndex(element: Item, index: number);\n\n  /**\n   * Manage state by observing which items have the attribute-for-selected,\n   * and removing attribute for selected from previously selected items.\n   *\n   * Caches previous values so that we can call requestUpdate\n   * @param  mutationRecords\n   */\n  mutated(mutationRecords: (MutationRecord & { target: HTMLElement })[]): void;\n\n  /**\n   * Manage state by observing which items have the attribute-for-selected\n   */\n  initMutationObserver(): void;\n\n  /**\n   * Determines which children are 'items' according to the static 'allowedItems' property\n   * Updates the `items` read-only property\n   * @fires items-changed\n   * @param  maybeEvent slotchange event\n   */\n  updateItems(maybeEvent?: SlotchangeEvent): void;\n\n  /**\n   * Update the read-only focusedIndex property\n   * @param  focusedIndex the newly selected item's index\n   */\n  updateFocusedIndex(focusedIndex: number): void;\n\n  /**\n   * Update the read-only focusedItem property\n   * @param  focusedItem the newly selected item\n   */\n  updateFocusedItem(focusedItem: Item): void;\n\n  updateSelected({ previousSelectedItem, previousSelectedIndex }: {\n    previousSelectedItem: Item | Item[],\n    previousSelectedIndex: number | number[]\n  }): void;\n\n  /**\n   * Actually updates the selected index\n   * @param  value index to select\n   */\n  setSelectedIndex(value: number): void;\n\n  /**\n   * Updates selected index when an array is passed\n   * @param   indices indices of items to select\n   */\n  selectMultiIndex(indices: number[]): void;\n\n  /**\n   * Handles keyboard events\n   * Lets user select items with the arrow keys\n   */\n  onKeydown(event: KeyboardEvent): void;\n\n  /**\n   * Handles a change in the items.\n   * @param   event items-changed event\n   */\n  onItemsChanged?(event: CustomEvent): void\n\n  onSelect?(): void\n\n  /**\n   * Focuses an item.\n   * @param  focusedItem\n   */\n  focusItem(focusedItem: Item): void;\n\n  /**\n   * Unfocuses an item.\n   */\n  unfocusItem(item: Item): void;\n\n  /**\n   * Toggles the selected state of the focused item.\n   */\n  toggleFocusedItem(): void;\n\n  /**\n   * React to `selectedItem` or `selectedIndex` changing\n   */\n  selectedItemChanged(): void;\n}\n\nconst isSlotchangeEvent = (event: unknown): event is SlotchangeEvent =>\n  event instanceof Event &&\n  event.type !== 'slotchange';\n\nconst isAllowedChild = (allowedChildren: string[]|RegExp) => (node: Node): node is Item =>\n    !(node instanceof HTMLElement) ? false\n  : Array.isArray(allowedChildren) ? allowedChildren.includes(node.tagName.toLowerCase())\n  : allowedChildren instanceof RegExp ? !!node.tagName.toLowerCase().match(allowedChildren)\n  : true;\n\nconst getValue = x => x && propOr(null, 'value', x);\n\nconst getIndex = (item: unknown, _index: number, array: unknown[]) =>\n  array.indexOf(item);\n\nconst hasAttribute = (attr: string) => (element: Element) =>\n  element.hasAttribute(attr);\n\nconst getItemIndex = propOr(-1, 'itemIndex');\n\nconst noop = () => {}; // eslint-disable-line @typescript-eslint/no-empty-function\n\nconst compose: typeof import('ramda').compose =\n  (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\n\nconst SelectedIndexConverter = {\n  fromAttribute(value, type) {\n    return (value.includes(',')) ? value.split(',').map(x => parseInt(x))\n    : parseInt(value);\n  },\n\n  toAttribute(value, type) {\n    return Array.isArray(value) ? value.join(',') : value;\n  },\n};\n\n/**\n * Provides methods and properties for a selecting element.\n *\n * The element's shadow root must contain an anonymous slot for items.\n *\n * If you define a static property `allowedChildren` (Array, String, or RegExp), the `items`\n * property will filter for those tag names based on their custom element class' static `is` property\n * or `localName`\n *\n * To select items that live in your shadow root, e.g. SVG children, you can override the\n * getters and update method:\n *\n * @fires select - When an item is selected\n *\n * @example\n * ```html\n * <my-select>\n *  #shadow-root\n *    <slot></slot>\n * </my-select>\n * ```\n *\n * @example\n * ```js\n * class HasSelectableShadowChildren extends SelectMixin {\n *   // override SelectMixin updateItems\n *   updateItems() {\n *     const { items: oldItems } = this;\n *     const items = Array.from(this.shadowRoot.querySelectorAll('svg rect'));\n *     items.forEach((element, index) => {\n *       element.itemIndex = index;\n *       element.setAttribute('data-item-index', index.toString());\n *     });\n *     this._items = items;\n *     this.requestUpdate('items', oldItems);\n *     this.fire('items-changed', items);\n *   }\n *\n *   // Override SelectMixin getter\n *   get selectedItem() { return this.shadowRoot.querySelector('rect.active'); }\n *   set selectedItem(_) {}\n *  }\n * ```\n *\n */\nfunction SelectMixinImpl<TBase extends Constructor<LitElement>>(\n  superclass: TBase\n) {\n  class MixedSelectMixinElement extends FireMixin(superclass) {\n    static allowedChildren: string[]|RegExp = /-/;\n\n    itemsMutationObserver: MutationObserver;\n\n    _focusedIndex: number;\n\n    _focusedItem: Item;\n\n    previousSelectedItem: Item | Item[];\n\n    previousSelectedIndex: number | number[];\n\n    /**\n     * The selectable items\n     * @readonly\n     */\n    @property({ type: Array })\n\n    get items(): Item[] {\n      return Array.isArray(this._items) ? this._items : [];\n    }\n\n    set items(_) { _; }\n\n    _items: Item[] = [];\n\n    /**\n     * Whether multiple selections are allowed\n     */\n    @property({ type: Boolean }) multi = false;\n\n    /**\n     * The index of the focused item\n     * @readonly\n     */\n    @property({ type: Number })\n\n    get focusedIndex() {\n      return this.items.indexOf(this.focusedItem);\n    }\n\n    set focusedIndex(_) { _; }\n\n    /**\n     * The focused item\n     * @readonly\n     */\n    @property({ type: Object })\n\n    get focusedItem() {\n      const [focusedItem] = this.items.filter(matches(':focus, :focus-within'));\n      return focusedItem;\n    }\n\n    set focusedItem(_) { _; }\n\n    /**\n     * The boolean attribute on items which, when present, indicates that the item is selected.\n     */\n    @property({ type: String, attribute: 'attribute-for-selected' })\n    attributeForSelected = 'selected';\n\n    /**\n     * The currently selected item's index\n     */\n    @property({\n      type: Number,\n      converter: SelectedIndexConverter,\n      attribute: 'selected-index',\n    })\n\n    get selectedIndex(): number | number[] {\n      const { multi, attributeForSelected, items, selectedItem } = this;\n      return (\n          !multi ? items.indexOf(<Item>selectedItem)\n        : items.filter(hasAttribute(attributeForSelected)).map(getIndex)\n      );\n    }\n\n    set selectedIndex(value) {\n        // not an array ? great, select,\n        !Array.isArray(value) ? this.setSelectedIndex(value)\n        // Array, but not multi, take the first value,\n      : !this.multi ? this.setSelectedIndex(value[0])\n        // Array and multi ? select all passed values.\n      : this.selectMultiIndex(value);\n    }\n\n    /**\n     * The currently selected Item\n     * @readonly\n     */\n    @property({ type: Object })\n\n    get selectedItem(): Item|Item[] {\n      const { multi, attributeForSelected, items } = this;\n      return (\n          multi ? items.filter(hasAttribute(attributeForSelected))\n        : this.querySelector(`[${attributeForSelected}]`) as Item\n      );\n    }\n\n    set selectedItem(_) { _; }\n\n    /**\n     * Selected Item's Value\n     * @readonly\n     */\n    @property({ type: Object })\n\n    get value(): unknown|unknown[] {\n      return (\n          this.multi && Array.isArray(this.selectedItem) ? this.selectedItem.map(getValue)\n        : getValue(this.selectedItem)\n      );\n    }\n\n    set value(_) { _; }\n\n    /**\n     * Whether one of the items is the active element (i.e. focused)\n     * @type  true when an item is active\n     * @readonly\n     */\n    get hasActiveItem(): boolean {\n      return !!(this.items?.some?.(isFocusedOrActive));\n    }\n\n    /**\n     * The anonymous slot for list items\n     */\n    @query('slot:not([name])') contentSlot: HTMLSlotElement;\n\n    // LIFECYCLE\n\n    /**\n     * Adds event listeners for things like click, select, keydown.\n     * Initializes the mutation observer\n     */\n    connectedCallback(): void {\n      super.connectedCallback();\n      this.addEventListener('items-changed', (this.onItemsChanged ?? noop));\n      this.addEventListener('keydown', this.onKeydown);\n      this.addEventListener('select', (this.onSelect ?? noop));\n      this.setAttribute('aria-haspopup', 'true');\n      this.initMutationObserver();\n    }\n\n    /**\n     * Clears event listeners to prevent memory leaks\n     */\n    disconnectedCallback(): void {\n      super.disconnectedCallback();\n      this.removeEventListener('items-changed', (this.onItemsChanged ?? noop));\n      this.removeEventListener('keydown', this.onKeydown);\n      this.removeEventListener('select', (this.onSelect ?? noop));\n      this.itemsMutationObserver.disconnect();\n    }\n\n    firstUpdated(changed: PropertyValues): void {\n      super.firstUpdated(changed);\n      this.contentSlot?.addEventListener?.('slotchange', this.updateItems);\n      // let's get this party started\n      this.updateItems();\n    }\n\n    updated(changed: PropertyValues): void {\n      super.updated && super.updated(changed);\n      if (changed.has('attributeForSelected')) this.initMutationObserver();\n      if (changed.has('selectedItem')) this.selectedItemChanged();\n    }\n\n    // PUBLIC METHODS\n\n    /**\n     * Updates the read-only `selectedItem` and `selectedIndex` properties\n     * Updates the `value` property\n     * @param  selectedIndex selectedIndex\n     */\n    selectIndex(selectedIndex: number): void {\n      this.selectedIndex = selectedIndex;\n    }\n\n    /**\n     * Selects the next item in the list.\n     * Wraps around to first item from last.\n     */\n    selectNext(): void {\n      if (this.multi) return;\n      const { items: { length }, selectedIndex } = this;\n      const lastItemIndex = length - 1;\n      const nextIndex =\n          selectedIndex === lastItemIndex ? 0\n          : typeof selectedIndex === 'number' ? selectedIndex + 1\n          // shouldn't get here\n          : -1;\n      this.selectIndex(nextIndex);\n    }\n\n    /**\n     * Selects the previous item in the list.\n     * Wraps around to last item from first.\n     */\n    selectPrevious(): void {\n      if (this.multi) return;\n      const { items: { length }, selectedIndex } = this;\n      const lastItemIndex = length - 1;\n      const previousIndex =\n          selectedIndex === 0 ? lastItemIndex\n        : typeof selectedIndex === 'number' ? selectedIndex - 1\n        // shouldn't get here\n        : -1;\n      this.selectIndex(previousIndex);\n    }\n\n    // PRIVATE METHODS\n\n    /**\n     * Updates the read-only `focusedIndex` property\n     * @param  focusedIndex focusedIndex\n     */\n    focusIndex(focusedIndex: number): void {\n      // Find the item\n      const focusedItem = this.items[focusedIndex];\n      this.focusItem(focusedItem);\n    }\n\n    /**\n     * Focuses the next item in the list.\n     * Wraps around to first item from last.\n     */\n    focusNext(): void {\n      const { focusedIndex, items: { length } } = this;\n      const nextIndex =\n          focusedIndex >= (length - 1) ? 0\n        : focusedIndex + 1;\n      this.focusIndex(nextIndex);\n    }\n\n    /**\n     * Focuses the previous item in the list.\n     * Wraps around to last item from first.\n     */\n    focusPrevious(): void {\n      const { focusedIndex } = this;\n      const previousIndex =\n          focusedIndex === 0 ? (this.items.length - 1)\n        : focusedIndex - 1;\n      this.focusIndex(previousIndex);\n    }\n\n    @bound setItemIndex(element: Item, index: number) {\n      element.itemIndex = index;\n      element.setAttribute('data-item-index', index.toString());\n    }\n\n    /**\n     * Manage state by observing which items have the attribute-for-selected,\n     * and removing attribute for selected from previously selected items.\n     *\n     * Caches previous values so that we can call requestUpdate\n     * @param  mutationRecords\n     */\n    @bound mutated(mutationRecords: (MutationRecord & { target: HTMLElement })[]): void {\n      const { attributeForSelected, multi } = this;\n      let { previousSelectedIndex, previousSelectedItem } = this;\n\n      // if `multi`, the user manages all the state themselves\n      if (!multi) {\n        // get the item which was just now selected,\n        // i.e. the first child which went from not having the attr to having it\n        // if no such child exists, we're probably unselecting.\n        const selectedRecord = mutationRecords\n          .find(({ oldValue, target }: MutationRecord & {target: Item}) =>\n            oldValue === null &&\n            target.hasAttribute(attributeForSelected)\n          );\n\n        // get the item which was just now unselected,\n        // i.e. the first child which went from having the attr to not having it\n        // if no such child exists, we're probably selecting - use the cached value\n        const prevRecord = mutationRecords\n          .find(({ oldValue, target }: MutationRecord) =>\n            oldValue === '' &&\n            !(<Item>target).hasAttribute(attributeForSelected)\n          );\n\n        previousSelectedIndex =\n          this.items.indexOf(<Item>prevRecord?.target);\n\n        // Unselect previous item\n        if (previousSelectedItem && previousSelectedItem !== selectedRecord?.target)\n          prevRecord?.target.removeAttribute(attributeForSelected);\n      }\n\n      this.updateSelected({ previousSelectedItem, previousSelectedIndex });\n    }\n\n    /**\n     * Manage state by observing which items have the attribute-for-selected\n     */\n    initMutationObserver(): void {\n      if (this.itemsMutationObserver) this.itemsMutationObserver.disconnect();\n      this.itemsMutationObserver = new MutationObserver(this.mutated);\n      this.itemsMutationObserver.observe(this, {\n        attributeFilter: [this.attributeForSelected],\n        attributeOldValue: true,\n        attributes: true,\n        childList: true,\n        subtree: true,\n      });\n    }\n\n    /**\n     * Determines which children are 'items' according to the static 'allowedItems' property\n     * Updates the `items` read-only property\n     * @fires items-changed\n     * @param  maybeEvent slotchange event\n     */\n    @bound updateItems(maybeEvent?: SlotchangeEvent): void {\n      const {\n        items: oldItems,\n        setItemIndex,\n      } = this;\n\n\n      // get child elements\n      const children =\n          !isSlotchangeEvent(maybeEvent) ? Array.from(this.children as HTMLCollection)\n        : maybeEvent.target.assignedElements();\n\n      const { allowedChildren } = <typeof SelectMixinElement> this.constructor;\n\n      // filter children for legitimate items\n      const items =\n        children.filter(isAllowedChild(allowedChildren));\n\n      // cache an `itemIndex` property on each item.\n      items.forEach(setItemIndex);\n\n      // Update the private `items` property\n      this._items = items;\n\n      this.requestUpdate('items', oldItems);\n\n      // Tell the \uD83C\uDF0E just how you feel\n      this.fire('items-changed', items);\n    }\n\n    /**\n     * Update the read-only focusedIndex property\n     * @param  focusedIndex the newly selected item's index\n     */\n    updateFocusedIndex(focusedIndex: number) {\n      const { focusedIndex: oldValue } = this;\n      this._focusedIndex = focusedIndex;\n      this.requestUpdate('focusedIndex', oldValue);\n    }\n\n    /**\n     * Update the read-only focusedItem property\n     * @param  focusedItem the newly selected item\n     */\n    updateFocusedItem(focusedItem: Item) {\n      const { focusedItem: oldValue } = this;\n      this._focusedItem = focusedItem;\n      this.requestUpdate('focusedItem', oldValue);\n    }\n\n    updateSelected({ previousSelectedItem, previousSelectedIndex }: {\n      previousSelectedItem: Item | Item[],\n      previousSelectedIndex: number | number[]\n    }) {\n      this.previousSelectedItem = this.selectedItem;\n      this.previousSelectedIndex = this.selectedIndex;\n      this.requestUpdate('selectedItem', previousSelectedItem);\n      this.requestUpdate('selectedIndex', previousSelectedIndex);\n    }\n\n    /**\n     * Actually updates the selected index\n     * @param  value index to select\n     */\n    @bound setSelectedIndex(value: number): void {\n      const {\n        attributeForSelected,\n        items,\n        multi,\n        selectedIndex: oldIndex,\n        selectedItem: oldItem,\n      } = this;\n\n      const index = typeof value === 'string' ? parseInt(value) : value;\n\n      // short circuit if there's no change\n      if (Number.isNaN(index) || oldIndex === index) return;\n\n      const newItem = items[index];\n\n      // manage state\n      if (oldItem instanceof HTMLElement && !multi) oldItem.removeAttribute(attributeForSelected);\n      if (newItem instanceof HTMLElement) newItem.setAttribute(attributeForSelected, '');\n    }\n\n    /**\n     * Updates selected index when an array is passed\n     * @param   indices indices of items to select\n     */\n    selectMultiIndex(indices: number[]): void {\n      const isItemNotSelected = not(compose(elem(indices), getItemIndex));\n      indices.map(this.setSelectedIndex);\n      this.items.filter(isItemNotSelected)\n        .forEach(item => item.removeAttribute(this.attributeForSelected));\n    }\n\n    /**\n     * Handles keyboard events\n     * Lets user select items with the arrow keys\n     */\n    @bound onKeydown(event: KeyboardEvent): void {\n      if (event.defaultPrevented) return;\n      const { key } = event;\n      switch (key) {\n        case 'ArrowUp':\n          event.preventDefault();\n          return this.focusPrevious();\n        case 'ArrowDown':\n          event.preventDefault();\n          return this.focusNext();\n        case ' ':\n          event.preventDefault();\n        case 'Enter': // eslint-disable-line no-fallthrough\n          return this.toggleFocusedItem();\n      }\n    }\n\n    /**\n     * Handles a change in the items.\n     * @param   event items-changed event\n     */\n    onItemsChanged?(event: CustomEvent): void\n\n    onSelect?(): void\n\n    /**\n     * Focuses an item.\n     * @param  focusedItem\n     */\n    @bound focusItem(focusedItem: Item): void {\n      this.updateFocusedIndex(this.items.indexOf(focusedItem));\n      this.updateFocusedItem(focusedItem);\n      if (!focusedItem) return;\n      focusedItem.focus();\n    }\n\n    /**\n     * Unfocuses an item.\n     */\n    @bound unfocusItem(item: Item): void {\n      /* istanbul ignore else */\n      if (item) {\n        item.blur();\n        item.tabIndex = -1;\n      }\n    }\n\n    /**\n     * Toggles the selected state of the focused item.\n     */\n    toggleFocusedItem(): void {\n      const { focusedItem, attributeForSelected } = this;\n      if (!focusedItem) return;\n      const isSelected = focusedItem.hasAttribute(attributeForSelected);\n      if (isSelected) focusedItem.removeAttribute(attributeForSelected);\n      else focusedItem.setAttribute(attributeForSelected, '');\n    }\n\n    /**\n     * React to `selectedItem` or `selectedIndex` changing\n     */\n    selectedItemChanged(): void {\n      if (this.selectedItem)\n        this.fire('select', this.selectedItem);\n    }\n  }\n\n  return MixedSelectMixinElement as unknown as (\n    & TBase\n    & Constructor<SelectMixinElement & FireMixinElement>\n    & { allowedChildren: string[]|RegExp; }\n  );\n}\n\nexport const SelectMixin = dedupeMixin(SelectMixinImpl);\n", "/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Whether the current browser supports `adoptedStyleSheets`.\n */\nexport const supportsAdoptingStyleSheets =\n  window.ShadowRoot &&\n  (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) &&\n  'adoptedStyleSheets' in Document.prototype &&\n  'replace' in CSSStyleSheet.prototype;\n\nexport type CSSResultOrNative = CSSResult | CSSStyleSheet;\n\nexport type CSSResultFlatArray = CSSResultOrNative[];\n\nexport type CSSResultArray = Array<CSSResultOrNative | CSSResultArray>;\n\nexport type CSSResultGroup = CSSResultOrNative | CSSResultArray;\n\nconst constructionToken = Symbol();\n\nexport class CSSResult {\n  readonly cssText: string;\n  private _styleSheet?: CSSStyleSheet;\n\n  constructor(cssText: string, safeToken: symbol) {\n    if (safeToken !== constructionToken) {\n      throw new Error(\n        'CSSResult is not constructable. Use `unsafeCSS` or `css` instead.'\n      );\n    }\n    this.cssText = cssText;\n  }\n\n  // Note, this is a getter so that it's lazy. In practice, this means\n  // stylesheets are not created until the first element instance is made.\n  get styleSheet(): CSSStyleSheet | undefined {\n    // Note, if `supportsAdoptingStyleSheets` is true then we assume\n    // CSSStyleSheet is constructable.\n    if (supportsAdoptingStyleSheets && this._styleSheet === undefined) {\n      this._styleSheet = new CSSStyleSheet();\n      this._styleSheet.replaceSync(this.cssText);\n    }\n    return this._styleSheet;\n  }\n\n  toString(): string {\n    return this.cssText;\n  }\n}\n\nconst cssResultCache = new Map<string, CSSResult>();\n\nconst getCSSResult = (cssText: string): CSSResult => {\n  let result = cssResultCache.get(cssText);\n  if (result === undefined) {\n    cssResultCache.set(\n      cssText,\n      (result = new CSSResult(cssText, constructionToken))\n    );\n  }\n  return result;\n};\n\nconst textFromCSSResult = (value: CSSResultGroup | number) => {\n  if (value instanceof CSSResult) {\n    return value.cssText;\n  } else if (typeof value === 'number') {\n    return value;\n  } else {\n    throw new Error(\n      `Value passed to 'css' function must be a 'css' function result: ` +\n        `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` +\n        `to ensure page security.`\n    );\n  }\n};\n\n/**\n * Wrap a value for interpolation in a [[`css`]] tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */\nexport const unsafeCSS = (value: unknown) => {\n  return getCSSResult(typeof value === 'string' ? value : String(value));\n};\n\n/**\n * Template tag which which can be used with LitElement's [[LitElement.styles |\n * `styles`]] property to set element styles. For security reasons, only literal\n * string values may be used. To incorporate non-literal values [[`unsafeCSS`]]\n * may be used inside a template string part.\n */\nexport const css = (\n  strings: TemplateStringsArray,\n  ...values: (CSSResultGroup | number)[]\n): CSSResultGroup => {\n  const cssText =\n    strings.length === 1\n      ? strings[0]\n      : values.reduce(\n          (acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1],\n          strings[0]\n        );\n  return getCSSResult(cssText);\n};\n\n/**\n * Applies the given styles to a `shadowRoot`. When Shadow DOM is\n * available but `adoptedStyleSheets` is not, styles are appended to the\n * `shadowRoot` to [mimic spec behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n * Note, when shimming is used, any styles that are subsequently placed into\n * the shadowRoot should be placed *before* any shimmed adopted styles. This\n * will match spec behavior that gives adopted sheets precedence over styles in\n * shadowRoot.\n */\nexport const adoptStyles = (\n  renderRoot: ShadowRoot,\n  styles: CSSResultFlatArray\n) => {\n  if (supportsAdoptingStyleSheets) {\n    (renderRoot as ShadowRoot).adoptedStyleSheets = styles.map((s) =>\n      s instanceof CSSStyleSheet ? s : s.styleSheet!\n    );\n  } else {\n    styles.forEach((s) => {\n      const style = document.createElement('style');\n      style.textContent = (s as CSSResult).cssText;\n      renderRoot.appendChild(style);\n    });\n  }\n};\n\nconst cssResultFromStyleSheet = (sheet: CSSStyleSheet) => {\n  let cssText = '';\n  for (const rule of sheet.cssRules) {\n    cssText += rule.cssText;\n  }\n  return unsafeCSS(cssText);\n};\n\nexport const getCompatibleStyle = supportsAdoptingStyleSheets\n  ? (s: CSSResultOrNative) => s\n  : (s: CSSResultOrNative) =>\n      s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Use this module if you want to create your own base class extending\n * [[ReactiveElement]].\n * @packageDocumentation\n */\n\nimport {\n  getCompatibleStyle,\n  adoptStyles,\n  CSSResultGroup,\n  CSSResultOrNative,\n  CSSResultFlatArray,\n} from './css-tag.js';\nimport type {\n  ReactiveController,\n  ReactiveControllerHost,\n} from './reactive-controller.js';\n\nexport * from './css-tag.js';\nexport type {\n  ReactiveController,\n  ReactiveControllerHost,\n} from './reactive-controller.js';\n\nconst DEV_MODE = true;\n\nlet requestUpdateThenable: {\n  then: (\n    onfulfilled?: (value: boolean) => void,\n    _onrejected?: () => void\n  ) => void;\n};\n\nif (DEV_MODE) {\n  // TODO(sorvell): Add a link to the docs about using dev v. production mode.\n  console.warn(`Running in dev mode. Do not use in production!`);\n\n  // Issue platform support warning.\n  if (\n    window.ShadyDOM?.inUse &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (globalThis as any)['reactiveElementPlatformSupport'] === undefined\n  ) {\n    console.warn(\n      `Shadow DOM is being polyfilled via ShadyDOM but ` +\n        `the \\`polyfill-support\\` module has not been loaded.`\n    );\n  }\n\n  requestUpdateThenable = {\n    then: (\n      onfulfilled?: (value: boolean) => void,\n      _onrejected?: () => void\n    ) => {\n      console.warn(\n        `\\`requestUpdate\\` no longer returns a Promise.` +\n          `Use \\`updateComplete\\` instead.`\n      );\n      if (onfulfilled !== undefined) {\n        onfulfilled(false);\n      }\n    },\n  };\n}\n\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\n/*@__INLINE__*/\nconst JSCompiler_renameProperty = <P extends PropertyKey>(\n  prop: P,\n  _obj: unknown\n): P => prop;\n\n/**\n * Converts property values to and from attribute values.\n */\nexport interface ComplexAttributeConverter<Type = unknown, TypeHint = unknown> {\n  /**\n   * Function called to convert an attribute value to a property\n   * value.\n   */\n  fromAttribute?(value: string | null, type?: TypeHint): Type;\n\n  /**\n   * Function called to convert a property value to an attribute\n   * value.\n   *\n   * It returns unknown instead of string, to be compatible with\n   * https://github.com/WICG/trusted-types (and similar efforts).\n   */\n  toAttribute?(value: Type, type?: TypeHint): unknown;\n}\n\ntype AttributeConverter<Type = unknown, TypeHint = unknown> =\n  | ComplexAttributeConverter<Type>\n  | ((value: string | null, type?: TypeHint) => Type);\n\n/**\n * Defines options for a property accessor.\n */\nexport interface PropertyDeclaration<Type = unknown, TypeHint = unknown> {\n  /**\n   * When set to `true`, indicates the property is internal private state. The\n   * property should not be set by users. When using TypeScript, this property\n   * should be marked as `private` or `protected`, and it is also a common\n   * practice to use a leading `_` in the name. The property is not added to\n   * `observedAttributes`.\n   */\n  readonly state?: boolean;\n\n  /**\n   * Indicates how and whether the property becomes an observed attribute.\n   * If the value is `false`, the property is not added to `observedAttributes`.\n   * If true or absent, the lowercased property name is observed (e.g. `fooBar`\n   * becomes `foobar`). If a string, the string value is observed (e.g\n   * `attribute: 'foo-bar'`).\n   */\n  readonly attribute?: boolean | string;\n\n  /**\n   * Indicates the type of the property. This is used only as a hint for the\n   * `converter` to determine how to convert the attribute\n   * to/from a property.\n   */\n  readonly type?: TypeHint;\n\n  /**\n   * Indicates how to convert the attribute to/from a property. If this value\n   * is a function, it is used to convert the attribute value a the property\n   * value. If it's an object, it can have keys for `fromAttribute` and\n   * `toAttribute`. If no `toAttribute` function is provided and\n   * `reflect` is set to `true`, the property value is set directly to the\n   * attribute. A default `converter` is used if none is provided; it supports\n   * `Boolean`, `String`, `Number`, `Object`, and `Array`. Note,\n   * when a property changes and the converter is used to update the attribute,\n   * the property is never updated again as a result of the attribute changing,\n   * and vice versa.\n   */\n  readonly converter?: AttributeConverter<Type, TypeHint>;\n\n  /**\n   * Indicates if the property should reflect to an attribute.\n   * If `true`, when the property is set, the attribute is set using the\n   * attribute name determined according to the rules for the `attribute`\n   * property option and the value of the property converted using the rules\n   * from the `converter` property option.\n   */\n  readonly reflect?: boolean;\n\n  /**\n   * A function that indicates if a property should be considered changed when\n   * it is set. The function should take the `newValue` and `oldValue` and\n   * return `true` if an update should be requested.\n   */\n  hasChanged?(value: Type, oldValue: Type): boolean;\n\n  /**\n   * Indicates whether an accessor will be created for this property. By\n   * default, an accessor will be generated for this property that requests an\n   * update when set. If this flag is `true`, no accessor will be created, and\n   * it will be the user's responsibility to call\n   * `this.requestUpdate(propertyName, oldValue)` to request an update when\n   * the property changes.\n   */\n  readonly noAccessor?: boolean;\n}\n\n/**\n * Map of properties to PropertyDeclaration options. For each property an\n * accessor is made, and the property is processed according to the\n * PropertyDeclaration options.\n */\nexport interface PropertyDeclarations {\n  readonly [key: string]: PropertyDeclaration;\n}\n\ntype PropertyDeclarationMap = Map<PropertyKey, PropertyDeclaration>;\n\ntype AttributeMap = Map<string, PropertyKey>;\n\n/**\n * Map of changed properties with old values. Takes an optional generic\n * interface corresponding to the declared element properties.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PropertyValues<T = any> = keyof T extends PropertyKey\n  ? Map<keyof T, unknown>\n  : never;\n\nexport const defaultConverter: ComplexAttributeConverter = {\n  toAttribute(value: unknown, type?: unknown): unknown {\n    switch (type) {\n      case Boolean:\n        value = value ? '' : null;\n        break;\n      case Object:\n      case Array:\n        // if the value is `null` or `undefined` pass this through\n        // to allow removing/no change behavior.\n        value = value == null ? value : JSON.stringify(value);\n        break;\n    }\n    return value;\n  },\n\n  fromAttribute(value: string | null, type?: unknown) {\n    let fromValue: unknown = value;\n    switch (type) {\n      case Boolean:\n        fromValue = value !== null;\n        break;\n      case Number:\n        fromValue = value === null ? null : Number(value);\n        break;\n      case Object:\n      case Array:\n        // Do *not* generate exception when invalid JSON is set as elements\n        // don't normally complain on being mis-configured.\n        // TODO(sorvell): Do generate exception in *dev mode*.\n        try {\n          // Assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n          fromValue = JSON.parse(value!) as unknown;\n        } catch (e) {\n          fromValue = null;\n        }\n        break;\n    }\n    return fromValue;\n  },\n};\n\nexport interface HasChanged {\n  (value: unknown, old: unknown): boolean;\n}\n\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nexport const notEqual: HasChanged = (value: unknown, old: unknown): boolean => {\n  // This ensures (old==NaN, value==NaN) always returns false\n  return old !== value && (old === old || value === value);\n};\n\nconst defaultPropertyDeclaration: PropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual,\n};\n\n/**\n * The Closure JS Compiler doesn't currently have good support for static\n * property semantics where \"this\" is dynamic (e.g.\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\n * this hack to bypass any rewriting by the compiler.\n */\nconst finalized = 'finalized';\n\n/**\n * A string representing one of the supported dev mode warnings classes.\n */\nexport type WarningKind = 'change-in-update' | 'migration';\n\nexport type Initializer = (element: ReactiveElement) => void;\n\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclassers to render updates as desired.\n * @noInheritDoc\n */\nexport abstract class ReactiveElement\n  extends HTMLElement\n  implements ReactiveControllerHost {\n  // Note: these are patched in only in DEV_MODE.\n  /**\n   * Read or set all the enabled warning kinds for this class.\n   *\n   * This property is only used in development builds.\n   *\n   * @nocollapse\n   * @category dev-mode\n   */\n  static enabledWarnings?: WarningKind[];\n\n  /**\n   * Enable the given warning kind for this class.\n   *\n   * This method only exists in development builds, so it should be accessed\n   * with a guard like:\n   *\n   * ```ts\n   * // Enable for all ReactiveElement classes\n   * ReactiveElement.enableWarning.?('migration');\n   *\n   * // Enable for all MyElement only\n   * MyElement.enableWarning.?('migration');\n   * ```\n   *\n   * @nocollapse\n   * @category dev-mode\n   */\n  static enableWarning?: (warningKind: WarningKind) => void;\n\n  /**\n   * Disable the given warning kind for this class.\n   *\n   * This method only exists in development builds, so it should be accessed\n   * with a guard like:\n   *\n   * ```ts\n   * // Disable for all ReactiveElement classes\n   * ReactiveElement.disableWarning.?('migration');\n   *\n   * // Disable for all MyElement only\n   * MyElement.disableWarning.?('migration');\n   * ```\n   *\n   * @nocollapse\n   * @category dev-mode\n   */\n  static disableWarning?: (warningKind: WarningKind) => void;\n\n  /**\n   * @nocollapse\n   */\n  static addInitializer(initializer: Initializer) {\n    this._initializers ??= [];\n    this._initializers.push(initializer);\n  }\n\n  static _initializers?: Initializer[];\n\n  /*\n   * Due to closure compiler ES6 compilation bugs, @nocollapse is required on\n   * all static methods and properties with initializers.  Reference:\n   * - https://github.com/google/closure-compiler/issues/1776\n   */\n\n  /**\n   * Maps attribute names to properties; for example `foobar` attribute to\n   * `fooBar` property. Created lazily on user subclasses when finalizing the\n   * class.\n   * @nocollapse\n   */\n  private static __attributeToPropertyMap: AttributeMap;\n\n  /**\n   * Marks class as having finished creating properties.\n   */\n  protected static [finalized] = true;\n\n  /**\n   * Memoized list of all element properties, including any superclass properties.\n   * Created lazily on user subclasses when finalizing the class.\n   * @nocollapse\n   * @category properties\n   */\n  static elementProperties: PropertyDeclarationMap = new Map();\n\n  /**\n   * User-supplied object that maps property names to `PropertyDeclaration`\n   * objects containing options for configuring reactive properties. When\n   * a reactive property is set the element will update and render.\n   *\n   * By default properties are public fields, and as such, they should be\n   * considered as primarily settable by element users, either via attribute or\n   * the property itself.\n   *\n   * Generally, properties that are changed by the element should be private or\n   * protected fields and should use the `state: true` option. Properties\n   * marked as `state` do not reflect from the corresponding attribute\n   *\n   * However, sometimes element code does need to set a public property. This\n   * should typically only be done in response to user interaction, and an event\n   * should be fired informing the user; for example, a checkbox sets its\n   * `checked` property when clicked and fires a `changed` event. Mutating\n   * public properties should typically not be done for non-primitive (object or\n   * array) properties. In other cases when an element needs to manage state, a\n   * private property set with the `state: true` option should be used. When\n   * needed, state properties can be initialized via public properties to\n   * facilitate complex interactions.\n   * @nocollapse\n   * @category properties\n   */\n  static properties: PropertyDeclarations;\n\n  /**\n   * Memoized list of all element styles.\n   * Created lazily on user subclasses when finalizing the class.\n   * @nocollapse\n   * @category styles\n   */\n  static elementStyles: CSSResultFlatArray = [];\n\n  /**\n   * Array of styles to apply to the element. The styles should be defined\n   * using the [[`css`]] tag function or via constructible stylesheets.\n   * @nocollapse\n   * @category styles\n   */\n  static styles?: CSSResultGroup;\n\n  /**\n   * Returns a list of attributes corresponding to the registered properties.\n   * @nocollapse\n   * @category attributes\n   */\n  static get observedAttributes() {\n    // note: piggy backing on this to ensure we're finalized.\n    this.finalize();\n    const attributes: string[] = [];\n    // Use forEach so this works even if for/of loops are compiled to for loops\n    // expecting arrays\n    this.elementProperties.forEach((v, p) => {\n      const attr = this.__attributeNameForProperty(p, v);\n      if (attr !== undefined) {\n        this.__attributeToPropertyMap.set(attr, p);\n        attributes.push(attr);\n      }\n    });\n    return attributes;\n  }\n\n  /**\n   * Creates a property accessor on the element prototype if one does not exist\n   * and stores a PropertyDeclaration for the property with the given options.\n   * The property setter calls the property's `hasChanged` property option\n   * or uses a strict identity check to determine whether or not to request\n   * an update.\n   *\n   * This method may be overridden to customize properties; however,\n   * when doing so, it's important to call `super.createProperty` to ensure\n   * the property is setup correctly. This method calls\n   * `getPropertyDescriptor` internally to get a descriptor to install.\n   * To customize what properties do when they are get or set, override\n   * `getPropertyDescriptor`. To customize the options for a property,\n   * implement `createProperty` like this:\n   *\n   * static createProperty(name, options) {\n   *   options = Object.assign(options, {myOption: true});\n   *   super.createProperty(name, options);\n   * }\n   *\n   * @nocollapse\n   * @category properties\n   */\n  static createProperty(\n    name: PropertyKey,\n    options: PropertyDeclaration = defaultPropertyDeclaration\n  ) {\n    // if this is a state property, force the attribute to false.\n    if (options.state) {\n      // Cast as any since this is readonly.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (options as any).attribute = false;\n    }\n    // Note, since this can be called by the `@property` decorator which\n    // is called before `finalize`, we ensure finalization has been kicked off.\n    this.finalize();\n    this.elementProperties.set(name, options);\n    // Do not generate an accessor if the prototype already has one, since\n    // it would be lost otherwise and that would never be the user's intention;\n    // Instead, we expect users to call `requestUpdate` themselves from\n    // user-defined accessors. Note that if the super has an accessor we will\n    // still overwrite it\n    if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {\n      const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n      const descriptor = this.getPropertyDescriptor(name, key, options);\n      if (descriptor !== undefined) {\n        Object.defineProperty(this.prototype, name, descriptor);\n      }\n    }\n  }\n\n  /**\n   * Returns a property descriptor to be defined on the given named property.\n   * If no descriptor is returned, the property will not become an accessor.\n   * For example,\n   *\n   *   class MyElement extends LitElement {\n   *     static getPropertyDescriptor(name, key, options) {\n   *       const defaultDescriptor =\n   *           super.getPropertyDescriptor(name, key, options);\n   *       const setter = defaultDescriptor.set;\n   *       return {\n   *         get: defaultDescriptor.get,\n   *         set(value) {\n   *           setter.call(this, value);\n   *           // custom action.\n   *         },\n   *         configurable: true,\n   *         enumerable: true\n   *       }\n   *     }\n   *   }\n   *\n   * @nocollapse\n   * @category properties\n   */\n  protected static getPropertyDescriptor(\n    name: PropertyKey,\n    key: string | symbol,\n    options: PropertyDeclaration\n  ) {\n    return {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      get(): any {\n        return (this as {[key: string]: unknown})[key as string];\n      },\n      set(this: ReactiveElement, value: unknown) {\n        const oldValue = ((this as {}) as {[key: string]: unknown})[\n          name as string\n        ];\n        ((this as {}) as {[key: string]: unknown})[key as string] = value;\n        ((this as unknown) as ReactiveElement).requestUpdate(\n          name,\n          oldValue,\n          options\n        );\n      },\n      configurable: true,\n      enumerable: true,\n    };\n  }\n\n  /**\n   * Returns the property options associated with the given property.\n   * These options are defined with a PropertyDeclaration via the `properties`\n   * object or the `@property` decorator and are registered in\n   * `createProperty(...)`.\n   *\n   * Note, this method should be considered \"final\" and not overridden. To\n   * customize the options for a given property, override `createProperty`.\n   *\n   * @nocollapse\n   * @final\n   * @category properties\n   */\n  protected static getPropertyOptions(name: PropertyKey) {\n    return this.elementProperties.get(name) || defaultPropertyDeclaration;\n  }\n\n  /**\n   * Creates property accessors for registered properties, sets up element\n   * styling, and ensures any superclasses are also finalized. Returns true if\n   * the element was finalized.\n   * @nocollapse\n   */\n  protected static finalize() {\n    if (this.hasOwnProperty(finalized)) {\n      return false;\n    }\n    this[finalized] = true;\n    // finalize any superclasses\n    const superCtor = Object.getPrototypeOf(this) as typeof ReactiveElement;\n    superCtor.finalize();\n    this.elementProperties = new Map(superCtor.elementProperties);\n    // initialize Map populated in observedAttributes\n    this.__attributeToPropertyMap = new Map();\n    // make any properties\n    // Note, only process \"own\" properties since this element will inherit\n    // any properties defined on the superClass, and finalization ensures\n    // the entire prototype chain is finalized.\n    if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n      const props = this.properties;\n      // support symbols in properties (IE11 does not support this)\n      const propKeys = [\n        ...Object.getOwnPropertyNames(props),\n        ...Object.getOwnPropertySymbols(props),\n      ];\n      // This for/of is ok because propKeys is an array\n      for (const p of propKeys) {\n        // note, use of `any` is due to TypeScript lack of support for symbol in\n        // index types\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.createProperty(p, (props as any)[p]);\n      }\n    }\n    this.elementStyles = this.finalizeStyles(this.styles);\n    // DEV mode warnings\n    if (DEV_MODE) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const warnRemoved = (obj: any, name: string) => {\n        if (obj[name] !== undefined) {\n          console.warn(\n            `\\`${name}\\` is implemented. It ` +\n              `has been removed from this version of ReactiveElement.` +\n              ` See the changelog at https://github.com/lit/lit/blob/main/packages/reactive-element/CHANGELOG.md`\n          );\n        }\n      };\n      [`initialize`, `requestUpdateInternal`, `_getUpdateComplete`].forEach(\n        (name: string) =>\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          warnRemoved(this.prototype as any, name)\n      );\n    }\n    return true;\n  }\n\n  /**\n   * Options used when calling `attachShadow`. Set this property to customize\n   * the options for the shadowRoot; for example, to create a closed\n   * shadowRoot: `{mode: 'closed'}`.\n   *\n   * Note, these options are used in `createRenderRoot`. If this method\n   * is customized, options should be respected if possible.\n   * @nocollapse\n   * @category rendering\n   */\n  static shadowRootOptions: ShadowRootInit = {mode: 'open'};\n\n  /**\n   * Takes the styles the user supplied via the `static styles` property and\n   * returns the array of styles to apply to the element.\n   * Override this method to integrate into a style management system.\n   *\n   * Styles are deduplicated preserving the _last_ instance in the list. This\n   * is a performance optimization to avoid duplicated styles that can occur\n   * especially when composing via subclassing. The last item is kept to try\n   * to preserve the cascade order with the assumption that it's most important\n   * that last added styles override previous styles.\n   *\n   * @nocollapse\n   * @category styles\n   */\n  protected static finalizeStyles(styles?: CSSResultGroup): CSSResultFlatArray {\n    const elementStyles = [];\n    if (Array.isArray(styles)) {\n      // Dedupe the flattened array in reverse order to preserve the last items.\n      // TODO(sorvell): casting to Array<unknown> works around TS error that\n      // appears to come from trying to flatten a type CSSResultArray.\n      const set = new Set((styles as Array<unknown>).flat(Infinity).reverse());\n      // Then preserve original order by adding the set items in reverse order.\n      for (const s of set) {\n        elementStyles.unshift(getCompatibleStyle(s as CSSResultOrNative));\n      }\n    } else if (styles !== undefined) {\n      elementStyles.push(getCompatibleStyle(styles));\n    }\n    return elementStyles;\n  }\n\n  /**\n   * Node or ShadowRoot into which element DOM should be rendered. Defaults\n   * to an open shadowRoot.\n   * @category rendering\n   */\n  readonly renderRoot!: HTMLElement | ShadowRoot;\n\n  /**\n   * Returns the property name for the given attribute `name`.\n   * @nocollapse\n   */\n  private static __attributeNameForProperty(\n    name: PropertyKey,\n    options: PropertyDeclaration\n  ) {\n    const attribute = options.attribute;\n    return attribute === false\n      ? undefined\n      : typeof attribute === 'string'\n      ? attribute\n      : typeof name === 'string'\n      ? name.toLowerCase()\n      : undefined;\n  }\n\n  private __instanceProperties?: PropertyValues = new Map();\n  // Initialize to an unresolved Promise so we can make sure the element has\n  // connected before first update.\n  private __updatePromise!: Promise<boolean>;\n\n  private __pendingConnectionPromise: Promise<void> | undefined = undefined;\n  private __enableConnection: (() => void) | undefined = undefined;\n\n  /**\n   * @category updates\n   */\n  isUpdatePending = false;\n\n  /**\n   * @category updates\n   */\n  hasUpdated = false;\n\n  /**\n   * Map with keys for any properties that have changed since the last\n   * update cycle with previous values.\n   *\n   * @internal\n   */\n  _$changedProperties!: PropertyValues;\n\n  /**\n   * Map with keys of properties that should be reflected when updated.\n   */\n  private __reflectingProperties?: Map<PropertyKey, PropertyDeclaration>;\n\n  /**\n   * Name of currently reflecting property\n   */\n  private __reflectingProperty: PropertyKey | null = null;\n\n  /**\n   * Set of controllers.\n   */\n  private __controllers?: ReactiveController[];\n\n  constructor() {\n    super();\n    this._initialize();\n  }\n\n  /**\n   * Internal only override point for customizing work done when elements\n   * are constructed.\n   *\n   * @internal\n   */\n  _initialize() {\n    this.__updatePromise = new Promise<boolean>(\n      (res) => (this.enableUpdating = res)\n    );\n    this._$changedProperties = new Map();\n    this.__saveInstanceProperties();\n    // ensures first update will be caught by an early access of\n    // `updateComplete`\n    this.requestUpdate();\n    (this.constructor as typeof ReactiveElement)._initializers?.forEach((i) =>\n      i(this)\n    );\n  }\n\n  /**\n   * @category controllers\n   */\n  addController(controller: ReactiveController) {\n    (this.__controllers ??= []).push(controller);\n    // If a controller is added after the element has been connected,\n    // call hostConnected. Note, re-using existence of `renderRoot` here\n    // (which is set in connectedCallback) to avoid the need to track a\n    // first connected state.\n    if (this.renderRoot !== undefined && this.isConnected) {\n      controller.hostConnected?.();\n    }\n  }\n\n  /**\n   * @category controllers\n   */\n  removeController(controller: ReactiveController) {\n    // Note, if the indexOf is -1, the >>> will flip the sign which makes the\n    // splice do nothing.\n    this.__controllers?.splice(this.__controllers.indexOf(controller) >>> 0, 1);\n  }\n\n  /**\n   * Fixes any properties set on the instance before upgrade time.\n   * Otherwise these would shadow the accessor and break these properties.\n   * The properties are stored in a Map which is played back after the\n   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n   * (<=41), properties created for native platform properties like (`id` or\n   * `name`) may not have default values set in the element constructor. On\n   * these browsers native properties appear on instances and therefore their\n   * default value will overwrite any element default (e.g. if the element sets\n   * this.id = 'id' in the constructor, the 'id' will become '' since this is\n   * the native platform default).\n   */\n  private __saveInstanceProperties() {\n    // Use forEach so this works even if for/of loops are compiled to for loops\n    // expecting arrays\n    (this.constructor as typeof ReactiveElement).elementProperties.forEach(\n      (_v, p) => {\n        if (this.hasOwnProperty(p)) {\n          this.__instanceProperties!.set(p, this[p as keyof this]);\n          delete this[p as keyof this];\n        }\n      }\n    );\n  }\n\n  /**\n   * Returns the node into which the element should render and by default\n   * creates and returns an open shadowRoot. Implement to customize where the\n   * element's DOM is rendered. For example, to render into the element's\n   * childNodes, return `this`.\n   *\n   * @return Returns a node into which to render.\n   * @category rendering\n   */\n  protected createRenderRoot(): Element | ShadowRoot {\n    const renderRoot =\n      this.shadowRoot ??\n      this.attachShadow(\n        (this.constructor as typeof ReactiveElement).shadowRootOptions\n      );\n    adoptStyles(\n      renderRoot,\n      (this.constructor as typeof ReactiveElement).elementStyles\n    );\n    return renderRoot;\n  }\n\n  /**\n   * On first connection, creates the element's renderRoot, sets up\n   * element styling, and enables updating.\n   * @category lifecycle\n   */\n  connectedCallback() {\n    // create renderRoot before first update.\n    if (this.renderRoot === undefined) {\n      (this as {\n        renderRoot: Element | DocumentFragment;\n      }).renderRoot = this.createRenderRoot();\n    }\n    this.enableUpdating(true);\n    this.__controllers?.forEach((c) => c.hostConnected?.());\n    // If we were disconnected, re-enable updating by resolving the pending\n    // connection promise\n    if (this.__enableConnection) {\n      this.__enableConnection();\n      this.__pendingConnectionPromise = this.__enableConnection = undefined;\n    }\n  }\n\n  /**\n   * Note, this method should be considered final and not overridden. It is\n   * overridden on the element instance with a function that triggers the first\n   * update.\n   * @category updates\n   */\n  protected enableUpdating(_requestedUpdate: boolean) {}\n\n  /**\n   * Allows for `super.disconnectedCallback()` in extensions while\n   * reserving the possibility of making non-breaking feature additions\n   * when disconnecting at some point in the future.\n   * @category lifecycle\n   */\n  disconnectedCallback() {\n    this.__controllers?.forEach((c) => c.hostDisconnected?.());\n    this.__pendingConnectionPromise = new Promise(\n      (r) => (this.__enableConnection = r)\n    );\n  }\n\n  /**\n   * Synchronizes property values when attributes change.\n   * @category attributes\n   */\n  attributeChangedCallback(\n    name: string,\n    _old: string | null,\n    value: string | null\n  ) {\n    this._$attributeToProperty(name, value);\n  }\n\n  private __propertyToAttribute(\n    name: PropertyKey,\n    value: unknown,\n    options: PropertyDeclaration = defaultPropertyDeclaration\n  ) {\n    const attr = (this\n      .constructor as typeof ReactiveElement).__attributeNameForProperty(\n      name,\n      options\n    );\n    if (attr !== undefined && options.reflect === true) {\n      const toAttribute =\n        (options.converter as ComplexAttributeConverter)?.toAttribute ??\n        defaultConverter.toAttribute;\n      const attrValue = toAttribute!(value, options.type);\n      if (\n        DEV_MODE &&\n        (this.constructor as typeof ReactiveElement).enabledWarnings!.indexOf(\n          'migration'\n        ) >= 0 &&\n        attrValue === undefined\n      ) {\n        console.warn(\n          `The attribute value for the ` +\n            `${name as string} property is undefined. The attribute will be ` +\n            `removed, but in the previous version of ReactiveElement, the ` +\n            `attribute would not have changed.`\n        );\n      }\n      // Track if the property is being reflected to avoid\n      // setting the property again via `attributeChangedCallback`. Note:\n      // 1. this takes advantage of the fact that the callback is synchronous.\n      // 2. will behave incorrectly if multiple attributes are in the reaction\n      // stack at time of calling. However, since we process attributes\n      // in `update` this should not be possible (or an extreme corner case\n      // that we'd like to discover).\n      // mark state reflecting\n      this.__reflectingProperty = name;\n      if (attrValue == null) {\n        this.removeAttribute(attr);\n      } else {\n        this.setAttribute(attr, attrValue as string);\n      }\n      // mark state not reflecting\n      this.__reflectingProperty = null;\n    }\n  }\n\n  /** @internal */\n  _$attributeToProperty(name: string, value: string | null) {\n    const ctor = this.constructor as typeof ReactiveElement;\n    // Note, hint this as an `AttributeMap` so closure clearly understands\n    // the type; it has issues with tracking types through statics\n    const propName = (ctor.__attributeToPropertyMap as AttributeMap).get(name);\n    // Use tracking info to avoid reflecting a property value to an attribute\n    // if it was just set because the attribute changed.\n    if (propName !== undefined && this.__reflectingProperty !== propName) {\n      const options = ctor.getPropertyOptions(propName);\n      const converter = options.converter;\n      const fromAttribute =\n        (converter as ComplexAttributeConverter)?.fromAttribute ??\n        (typeof converter === 'function'\n          ? (converter as (value: string | null, type?: unknown) => unknown)\n          : null) ??\n        defaultConverter.fromAttribute;\n      // mark state reflecting\n      this.__reflectingProperty = propName;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this[propName as keyof this] = fromAttribute!(value, options.type) as any;\n      // mark state not reflecting\n      this.__reflectingProperty = null;\n    }\n  }\n\n  /**\n   * Requests an update which is processed asynchronously. This should be called\n   * when an element should update based on some state not triggered by setting\n   * a reactive property. In this case, pass no arguments. It should also be\n   * called when manually implementing a property setter. In this case, pass the\n   * property `name` and `oldValue` to ensure that any configured property\n   * options are honored.\n   *\n   * @param name name of requesting property\n   * @param oldValue old value of requesting property\n   * @param options property options to use instead of the previously\n   *     configured options\n   * @category updates\n   */\n  requestUpdate(\n    name?: PropertyKey,\n    oldValue?: unknown,\n    options?: PropertyDeclaration\n  ): void {\n    let shouldRequestUpdate = true;\n    // If we have a property key, perform property update steps.\n    if (name !== undefined) {\n      options =\n        options ||\n        (this.constructor as typeof ReactiveElement).getPropertyOptions(name);\n      const hasChanged = options.hasChanged || notEqual;\n      if (hasChanged(this[name as keyof this], oldValue)) {\n        if (!this._$changedProperties.has(name)) {\n          this._$changedProperties.set(name, oldValue);\n        }\n        // Add to reflecting properties set.\n        // Note, it's important that every change has a chance to add the\n        // property to `_reflectingProperties`. This ensures setting\n        // attribute + property reflects correctly.\n        if (options.reflect === true && this.__reflectingProperty !== name) {\n          if (this.__reflectingProperties === undefined) {\n            this.__reflectingProperties = new Map();\n          }\n          this.__reflectingProperties.set(name, options);\n        }\n      } else {\n        // Abort the request if the property should not be considered changed.\n        shouldRequestUpdate = false;\n      }\n    }\n    if (!this.isUpdatePending && shouldRequestUpdate) {\n      this.__updatePromise = this.__enqueueUpdate();\n    }\n    // Note, since this no longer returns a promise, in dev mode we return a\n    // thenable which warns if it's called.\n    return DEV_MODE ? ((requestUpdateThenable as unknown) as void) : undefined;\n  }\n\n  /**\n   * Sets up the element to asynchronously update.\n   */\n  private async __enqueueUpdate() {\n    this.isUpdatePending = true;\n    try {\n      // Ensure any previous update has resolved before updating.\n      // This `await` also ensures that property changes are batched.\n      await this.__updatePromise;\n      // If we were disconnected, wait until re-connected to flush an update\n      while (this.__pendingConnectionPromise) {\n        await this.__pendingConnectionPromise;\n      }\n    } catch (e) {\n      // Refire any previous errors async so they do not disrupt the update\n      // cycle. Errors are refired so developers have a chance to observe\n      // them, and this can be done by implementing\n      // `window.onunhandledrejection`.\n      Promise.reject(e);\n    }\n    const result = this.performUpdate();\n    // If `performUpdate` returns a Promise, we await it. This is done to\n    // enable coordinating updates with a scheduler. Note, the result is\n    // checked to avoid delaying an additional microtask unless we need to.\n    if (result != null) {\n      await result;\n    }\n    return !this.isUpdatePending;\n  }\n\n  /**\n   * Performs an element update. Note, if an exception is thrown during the\n   * update, `firstUpdated` and `updated` will not be called.\n   *\n   * You can override this method to change the timing of updates. If this\n   * method is overridden, `super.performUpdate()` must be called.\n   *\n   * For instance, to schedule updates to occur just before the next frame:\n   *\n   * ```\n   * protected async performUpdate(): Promise<unknown> {\n   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n   *   super.performUpdate();\n   * }\n   * ```\n   * @category updates\n   */\n  protected performUpdate(): void | Promise<unknown> {\n    // Abort any update if one is not pending when this is called.\n    // This can happen if `performUpdate` is called early to \"flush\"\n    // the update.\n    if (!this.isUpdatePending) {\n      return;\n    }\n    // create renderRoot before first update.\n    if (!this.hasUpdated) {\n      // Produce warning if any class properties are shadowed by class fields\n      if (DEV_MODE) {\n        const shadowedProperties: string[] = [];\n        (this.constructor as typeof ReactiveElement).elementProperties.forEach(\n          (_v, p) => {\n            if (this.hasOwnProperty(p) && !this.__instanceProperties?.has(p)) {\n              shadowedProperties.push(p as string);\n            }\n          }\n        );\n        if (shadowedProperties.length) {\n          // TODO(sorvell): Link to docs explanation of this issue.\n          console.warn(\n            `The following properties will not trigger updates as expected ` +\n              `because they are set using class fields: ` +\n              `${shadowedProperties.join(', ')}. ` +\n              `Native class fields and some compiled output will overwrite ` +\n              `accessors used for detecting changes. To fix this issue, ` +\n              `either initialize properties in the constructor or adjust ` +\n              `your compiler settings; for example, for TypeScript set ` +\n              `\\`useDefineForClassFields: false\\` in your \\`tsconfig.json\\`.`\n          );\n        }\n      }\n    }\n    // Mixin instance properties once, if they exist.\n    if (this.__instanceProperties) {\n      // Use forEach so this works even if for/of loops are compiled to for loops\n      // expecting arrays\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.__instanceProperties!.forEach((v, p) => ((this as any)[p] = v));\n      this.__instanceProperties = undefined;\n    }\n    let shouldUpdate = false;\n    const changedProperties = this._$changedProperties;\n    try {\n      shouldUpdate = this.shouldUpdate(changedProperties);\n      if (shouldUpdate) {\n        this.willUpdate(changedProperties);\n        this.__controllers?.forEach((c) => c.hostUpdate?.());\n        this.update(changedProperties);\n      } else {\n        this.__markUpdated();\n      }\n    } catch (e) {\n      // Prevent `firstUpdated` and `updated` from running when there's an\n      // update exception.\n      shouldUpdate = false;\n      // Ensure element can accept additional updates after an exception.\n      this.__markUpdated();\n      throw e;\n    }\n    // The update is no longer considered pending and further updates are now allowed.\n    if (shouldUpdate) {\n      this._$didUpdate(changedProperties);\n    }\n  }\n\n  /**\n   * @category updates\n   */\n  willUpdate(_changedProperties: PropertyValues) {}\n\n  // Note, this is an override point for polyfill-support.\n  // @internal\n  _$didUpdate(changedProperties: PropertyValues) {\n    this.__controllers?.forEach((c) => c.hostUpdated?.());\n    if (!this.hasUpdated) {\n      this.hasUpdated = true;\n      this.firstUpdated(changedProperties);\n    }\n    this.updated(changedProperties);\n    if (\n      DEV_MODE &&\n      this.isUpdatePending &&\n      (this.constructor as typeof ReactiveElement).enabledWarnings!.indexOf(\n        'change-in-update'\n      ) >= 0\n    ) {\n      console.warn(\n        `An update was requested (generally because a property was set) ` +\n          `after an update completed, causing a new update to be scheduled. ` +\n          `This is inefficient and should be avoided unless the next update ` +\n          `can only be scheduled as a side effect of the previous update.`\n      );\n    }\n  }\n\n  private __markUpdated() {\n    this._$changedProperties = new Map();\n    this.isUpdatePending = false;\n  }\n\n  /**\n   * Returns a Promise that resolves when the element has completed updating.\n   * The Promise value is a boolean that is `true` if the element completed the\n   * update without triggering another update. The Promise result is `false` if\n   * a property was set inside `updated()`. If the Promise is rejected, an\n   * exception was thrown during the update.\n   *\n   * To await additional asynchronous work, override the `getUpdateComplete`\n   * method. For example, it is sometimes useful to await a rendered element\n   * before fulfilling this Promise. To do this, first await\n   * `super.getUpdateComplete()`, then any subsequent state.\n   *\n   * @return A promise of a boolean that indicates if the update resolved\n   *     without triggering another update.\n   * @category updates\n   */\n  get updateComplete(): Promise<boolean> {\n    return this.getUpdateComplete();\n  }\n\n  /**\n   * Override point for the `updateComplete` promise.\n   *\n   * It is not safe to override the `updateComplete` getter directly due to a\n   * limitation in TypeScript which means it is not possible to call a\n   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n   * This method should be overridden instead. For example:\n   *\n   *   class MyElement extends LitElement {\n   *     async getUpdateComplete() {\n   *       await super.getUpdateComplete();\n   *       await this._myChild.updateComplete;\n   *     }\n   *   }\n   * @category updates\n   */\n  protected getUpdateComplete(): Promise<boolean> {\n    return this.__updatePromise;\n  }\n\n  /**\n   * Controls whether or not `update` should be called when the element requests\n   * an update. By default, this method always returns `true`, but this can be\n   * customized to control when to update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected shouldUpdate(_changedProperties: PropertyValues): boolean {\n    return true;\n  }\n\n  /**\n   * Updates the element. This method reflects property values to attributes.\n   * It can be overridden to render and keep updated element DOM.\n   * Setting properties inside this method will *not* trigger\n   * another update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected update(_changedProperties: PropertyValues) {\n    if (this.__reflectingProperties !== undefined) {\n      // Use forEach so this works even if for/of loops are compiled to for\n      // loops expecting arrays\n      this.__reflectingProperties.forEach((v, k) =>\n        this.__propertyToAttribute(k, this[k as keyof this], v)\n      );\n      this.__reflectingProperties = undefined;\n    }\n    this.__markUpdated();\n  }\n\n  /**\n   * Invoked whenever the element is updated. Implement to perform\n   * post-updating tasks via DOM APIs, for example, focusing an element.\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected updated(_changedProperties: PropertyValues) {}\n\n  /**\n   * Invoked when the element is first updated. Implement to perform one time\n   * work on the element after update.\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected firstUpdated(_changedProperties: PropertyValues) {}\n}\n\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['reactiveElementPlatformSupport']?.({ReactiveElement});\n\n// Dev mode warnings...\nif (DEV_MODE) {\n  // Default warning set.\n  ReactiveElement.enabledWarnings = ['change-in-update'];\n  const ensureOwnWarnings = function (ctor: typeof ReactiveElement) {\n    if (\n      !ctor.hasOwnProperty(JSCompiler_renameProperty('enabledWarnings', ctor))\n    ) {\n      ctor.enabledWarnings = ctor.enabledWarnings!.slice();\n    }\n  };\n  ReactiveElement.enableWarning = function (\n    this: typeof ReactiveElement,\n    warning: WarningKind\n  ) {\n    ensureOwnWarnings(this);\n    if (this.enabledWarnings!.indexOf(warning) < 0) {\n      this.enabledWarnings!.push(warning);\n    }\n  };\n  ReactiveElement.disableWarning = function (\n    this: typeof ReactiveElement,\n    warning: WarningKind\n  ) {\n    ensureOwnWarnings(this);\n    const i = this.enabledWarnings!.indexOf(warning);\n    if (i >= 0) {\n      this.enabledWarnings!.splice(i, 1);\n    }\n  };\n}\n\ndeclare global {\n  interface Window {\n    reactiveElementVersions: string[];\n  }\n}\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for ReactiveElement usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((globalThis as any)['reactiveElementVersions'] ??= []).push('1.0.0-rc.2');\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// IMPORTANT: these imports must be type-only\nimport type {Directive, DirectiveResult, PartInfo} from './directive.js';\n\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\nif (DEV_MODE) {\n  console.warn('lit-html is in dev mode. Not recommended for production!');\n}\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  window.ShadyDOM?.inUse &&\n  window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM!.wrap\n    : (node: Node) => node;\n\nconst trustedTypes = ((globalThis as unknown) as Partial<Window>).trustedTypes;\n\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n  ? trustedTypes.createPolicy('lit-html', {\n      createHTML: (s) => s,\n    })\n  : undefined;\n\n/**\n * Used to sanitize any value before it is written into the DOM. This can be\n * used to implement a security policy of allowed and disallowed values in\n * order to prevent XSS attacks.\n *\n * One way of using this callback would be to check attributes and properties\n * against a list of high risk fields, and require that values written to such\n * fields be instances of a class which is safe by construction. Closure's Safe\n * HTML Types is one implementation of this technique (\n * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).\n * The TrustedTypes polyfill in API-only mode could also be used as a basis\n * for this technique (https://github.com/WICG/trusted-types).\n *\n * @param node The HTML node (usually either a #text node or an Element) that\n *     is being written to. Note that this is just an exemplar node, the write\n *     may take place against another instance of the same class of node.\n * @param name The name of an attribute or property (for example, 'href').\n * @param type Indicates whether the write that's about to be performed will\n *     be to a property or a node.\n * @return A function that will sanitize this class of writes.\n */\nexport type SanitizerFactory = (\n  node: Node,\n  name: string,\n  type: 'property' | 'attribute'\n) => ValueSanitizer;\n\n/**\n * A function which can sanitize values that will be written to a specific kind\n * of DOM sink.\n *\n * See SanitizerFactory.\n *\n * @param value The value to sanitize. Will be the actual value passed into\n *     the lit-html template literal, so this could be of any type.\n * @return The value to write to the DOM. Usually the same as the input value,\n *     unless sanitization is needed.\n */\nexport type ValueSanitizer = (value: unknown) => unknown;\n\nconst identityFunction: ValueSanitizer = (value: unknown) => value;\nconst noopSanitizer: SanitizerFactory = (\n  _node: Node,\n  _name: string,\n  _type: 'property' | 'attribute'\n) => identityFunction;\n\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer: SanitizerFactory) => {\n  if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n    return;\n  }\n  if (sanitizerFactoryInternal !== noopSanitizer) {\n    throw new Error(\n      `Attempted to overwrite existing lit-html security policy.` +\n        ` setSanitizeDOMValueFactory should be called at most once.`\n    );\n  }\n  sanitizerFactoryInternal = newSanitizer;\n};\n\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n  sanitizerFactoryInternal = noopSanitizer;\n};\n\nconst createSanitizer: SanitizerFactory = (node, name, type) => {\n  return sanitizerFactoryInternal(node, name, type);\n};\n\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\nconst isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\n\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\n  'g'\n);\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\n\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n\ntype ResultType = typeof HTML_RESULT | typeof SVG_RESULT;\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The return type of the template tag functions.\n */\nexport type TemplateResult<T extends ResultType = ResultType> = {\n  _$litType$: T;\n  // TODO (justinfagnani): consider shorter names, like `s` and `v`. This is a\n  // semi-public API though. We can't just let Terser rename them for us,\n  // because we need TemplateResults to work between compatible versions of\n  // lit-html.\n  strings: TemplateStringsArray;\n  values: unknown[];\n};\n\nexport type HTMLTemplateResult = TemplateResult<typeof HTML_RESULT>;\n\nexport type SVGTemplateResult = TemplateResult<typeof SVG_RESULT>;\n\nexport interface CompiledTemplateResult {\n  // This is a factory in order to make template initialization lazy\n  // and allow ShadyRenderOptions scope to be passed in.\n  _$litType$: CompiledTemplate;\n  values: unknown[];\n}\n\nexport interface CompiledTemplate extends Omit<Template, 'el'> {\n  // el is overridden to be optional. We initialize it on first render\n  el?: HTMLTemplateElement;\n\n  // The prepared HTML string to create a template element from.\n  h: TrustedHTML;\n}\n\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = <T extends ResultType>(_$litType$: T) => (\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): TemplateResult<T> => ({\n  _$litType$,\n  strings,\n  values,\n});\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap<TemplateStringsArray, Template>();\n\nexport interface RenderOptions {\n  /**\n   * An object to use as the `this` value for event listeners. It's often\n   * useful to set this to the host component rendering a template.\n   */\n  host?: object;\n  /**\n   * A DOM node before which to render content in the container.\n   */\n  renderBefore?: ChildNode | null;\n  /**\n   * Node used for cloning the template (`importNode` will be called on this\n   * node). This controls the `ownerDocument` of the rendered DOM, along with\n   * any inherited context. Defaults to the global `document`.\n   */\n  creationScope?: {importNode(node: Node, deep?: boolean): Node};\n}\n\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (\n  value: unknown,\n  container: HTMLElement | DocumentFragment,\n  options?: RenderOptions\n): ChildPart => {\n  const partOwnerNode = options?.renderBefore ?? container;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let part: ChildPart = (partOwnerNode as any)._$litPart$;\n  if (part === undefined) {\n    const endNode = options?.renderBefore ?? null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (partOwnerNode as any)._$litPart$ = part = new ChildPart(\n      container.insertBefore(createMarker(), endNode),\n      endNode,\n      undefined,\n      options\n    );\n  }\n  part._$setValue(value);\n  return part;\n};\n\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n  render.setSanitizer = setSanitizer;\n  render.createSanitizer = createSanitizer;\n  if (DEV_MODE) {\n    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n  }\n}\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */,\n  null,\n  false\n);\n\nlet sanitizerFactoryInternal: SanitizerFactory = noopSanitizer;\n\n//\n// Classes only below here, const variable declarations only above here...\n//\n// Keeping variable declarations and classes together improves minification.\n// Interfaces and type aliases can be interleaved freely.\n//\n\n// Type for classes that have a `_directive` or `_directives[]` field, used by\n// `resolveDirective`\nexport interface DirectiveParent {\n  _$parent?: DirectiveParent;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (\n  strings: TemplateStringsArray,\n  type: ResultType\n): [TrustedHTML, Array<string | undefined>] => {\n  // Insert makers into the template HTML to represent the position of\n  // bindings. The following code scans the template strings to determine the\n  // syntactic position of the bindings. They can be in text position, where\n  // we insert an HTML comment, attribute value position, where we insert a\n  // sentinel string and re-write the attribute name, or inside a tag where\n  // we insert the sentinel string.\n  const l = strings.length - 1;\n  // Stores the case-sensitive bound attribute names in the order of their\n  // parts. ElementParts are also reflected in this array as undefined\n  // rather than a string, to disambiguate from attribute bindings.\n  const attrNames: Array<string | undefined> = [];\n  let html = type === SVG_RESULT ? '<svg>' : '';\n\n  // When we're inside a raw text tag (not it's text content), the regex\n  // will still be tagRegex so we can find attributes, but will switch to\n  // this regex when the tag ends.\n  let rawTextEndRegex: RegExp | undefined;\n\n  // The current parsing state, represented as a reference to one of the\n  // regexes\n  let regex = textEndRegex;\n\n  for (let i = 0; i < l; i++) {\n    const s = strings[i];\n    // The index of the end of the last attribute name. When this is\n    // positive at end of a string, it means we're in an attribute value\n    // position and need to rewrite the attribute name.\n    // We also use a special value of -2 to indicate that we encountered\n    // the end of a string in attribute name position.\n    let attrNameEndIndex = -1;\n    let attrName: string | undefined;\n    let lastIndex = 0;\n    let match!: RegExpExecArray | null;\n\n    // The conditions in this loop handle the current parse state, and the\n    // assignments to the `regex` variable are the state transitions.\n    while (lastIndex < s.length) {\n      // Make sure we start searching from where we previously left off\n      regex.lastIndex = lastIndex;\n      match = regex.exec(s);\n      if (match === null) {\n        break;\n      }\n      lastIndex = regex.lastIndex;\n      if (regex === textEndRegex) {\n        if (match[COMMENT_START] === '!--') {\n          regex = commentEndRegex;\n        } else if (match[COMMENT_START] !== undefined) {\n          // We started a weird comment, like </{\n          regex = comment2EndRegex;\n        } else if (match[TAG_NAME] !== undefined) {\n          if (rawTextElement.test(match[TAG_NAME])) {\n            // Record if we encounter a raw-text element. We'll switch to\n            // this regex at the end of the tag.\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n          }\n          regex = tagEndRegex;\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n          // dynamic tag name\n          regex = tagEndRegex;\n        }\n      } else if (regex === tagEndRegex) {\n        if (match[ENTIRE_MATCH] === '>') {\n          // End of a tag. If we had started a raw-text element, use that\n          // regex\n          regex = rawTextEndRegex ?? textEndRegex;\n          // We may be ending an unquoted attribute value, so make sure we\n          // clear any pending attrNameEndIndex\n          attrNameEndIndex = -1;\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\n          // Attribute name position\n          attrNameEndIndex = -2;\n        } else {\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n          attrName = match[ATTRIBUTE_NAME];\n          regex =\n            match[QUOTE_CHAR] === undefined\n              ? tagEndRegex\n              : match[QUOTE_CHAR] === '\"'\n              ? doubleQuoteAttrEndRegex\n              : singleQuoteAttrEndRegex;\n        }\n      } else if (\n        regex === doubleQuoteAttrEndRegex ||\n        regex === singleQuoteAttrEndRegex\n      ) {\n        regex = tagEndRegex;\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\n        regex = textEndRegex;\n      } else {\n        // Not one of the five state regexes, so it must be the dynamically\n        // created raw text regex and we're at the close of that element.\n        regex = tagEndRegex;\n        rawTextEndRegex = undefined;\n      }\n    }\n\n    if (DEV_MODE) {\n      // If we have a attrNameEndIndex, which indicates that we should\n      // rewrite the attribute name, assert that we're in a valid attribute\n      // position - either in a tag, or a quoted attribute value.\n      console.assert(\n        attrNameEndIndex === -1 ||\n          regex === tagEndRegex ||\n          regex === singleQuoteAttrEndRegex ||\n          regex === doubleQuoteAttrEndRegex,\n        'unexpected parse state B'\n      );\n    }\n\n    // We have four cases:\n    //  1. We're in text position, and not in a raw text element\n    //     (regex === textEndRegex): insert a comment marker.\n    //  2. We have a non-negative attrNameEndIndex which means we need to\n    //     rewrite the attribute name to add a bound attribute suffix.\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\n    //     plain marker.\n    //  4. We're somewhere else inside the tag. If we're in attribute name\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\n    //     generate a unique attribute name.\n\n    // Detect a binding next to self-closing tag end and insert a space to\n    // separate the marker from the tag end:\n    const end =\n      regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n    html +=\n      regex === textEndRegex\n        ? s + nodeMarker\n        : attrNameEndIndex >= 0\n        ? (attrNames.push(attrName!),\n          s.slice(0, attrNameEndIndex) +\n            boundAttributeSuffix +\n            s.slice(attrNameEndIndex)) +\n          marker +\n          end\n        : s +\n          marker +\n          (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);\n  }\n\n  const htmlResult: string | TrustedHTML =\n    html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n\n  // Returned as an array for terseness\n  return [\n    policy !== undefined\n      ? policy.createHTML(htmlResult)\n      : ((htmlResult as unknown) as TrustedHTML),\n    attrNames,\n  ];\n};\n\n/** @internal */\nexport type {Template};\nclass Template {\n  /** @internal */\n  el!: HTMLTemplateElement;\n  /** @internal */\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    {strings, _$litType$: type}: TemplateResult,\n    options?: RenderOptions\n  ) {\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this.el = Template.createElement(html, options);\n    walker.currentNode = this.el.content;\n\n    // Reparent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const content = this.el.content;\n      const svgElement = content.firstChild!;\n      svgElement.remove();\n      content.append(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          // We defer removing bound attributes because on IE we might not be\n          // iterating attributes in their template order, and would sometimes\n          // remove an attribute that we still need to create a part for.\n          const attrsToRemove = [];\n          for (const name of (node as Element).getAttributeNames()) {\n            // `name` is the name of the attribute we're iterating over, but not\n            // _neccessarily_ the name of the attribute we will create a part\n            // for. They can be different in browsers that don't iterate on\n            // attributes in source order. In that case the attrNames array\n            // contains the attribute name we'll process next. We only need the\n            // attribute name here to know if we should process a bound attribute\n            // on this element.\n            if (\n              name.endsWith(boundAttributeSuffix) ||\n              name.startsWith(marker)\n            ) {\n              const realName = attrNames[attrNameIndex++];\n              attrsToRemove.push(name);\n              if (realName !== undefined) {\n                // Lowercase for case-sensitive SVG attributes like viewBox\n                const value = (node as Element).getAttribute(\n                  realName.toLowerCase() + boundAttributeSuffix\n                )!;\n                const statics = value.split(marker);\n                const m = /([.?@])?(.*)/.exec(realName)!;\n                parts.push({\n                  type: ATTRIBUTE_PART,\n                  index: nodeIndex,\n                  name: m[2],\n                  strings: statics,\n                  ctor:\n                    m[1] === '.'\n                      ? PropertyPart\n                      : m[1] === '?'\n                      ? BooleanAttributePart\n                      : m[1] === '@'\n                      ? EventPart\n                      : AttributePart,\n                });\n              } else {\n                parts.push({\n                  type: ELEMENT_PART,\n                  index: nodeIndex,\n                });\n              }\n            }\n          }\n          for (const name of attrsToRemove) {\n            (node as Element).removeAttribute(name);\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = trustedTypes\n              ? ((trustedTypes.emptyScript as unknown) as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized in some browsers (TODO: check)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            // TODO (justinfagnani): consider whether it's even worth it to\n            // make bindings in comments work\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  static createElement(html: TrustedHTML, _options?: RenderOptions) {\n    const el = d.createElement('template');\n    el.innerHTML = (html as unknown) as string;\n    return el;\n  }\n}\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnectableChildren?: Set<Disconnectable>;\n}\n\nfunction resolveDirective(\n  part: ChildPart | AttributePart | ElementPart,\n  value: unknown,\n  parent: DirectiveParent = part,\n  attributeIndex?: number\n): unknown {\n  // Bail early if the value is explicitly noChange. Note, this means any\n  // nested directive is still attached and is not run.\n  if (value === noChange) {\n    return value;\n  }\n  let currentDirective =\n    attributeIndex !== undefined\n      ? (parent as AttributePart).__directives?.[attributeIndex]\n      : (parent as ChildPart | ElementPart | Directive).__directive;\n  const nextDirectiveConstructor = isPrimitive(value)\n    ? undefined\n    : (value as DirectiveResult)._$litDirective$;\n  if (currentDirective?.constructor !== nextDirectiveConstructor) {\n    currentDirective?._$setDirectiveConnected?.(false);\n    if (nextDirectiveConstructor === undefined) {\n      currentDirective = undefined;\n    } else {\n      currentDirective = new nextDirectiveConstructor(part as PartInfo);\n      currentDirective._$initialize(part, parent, attributeIndex);\n    }\n    if (attributeIndex !== undefined) {\n      ((parent as AttributePart).__directives ??= [])[\n        attributeIndex\n      ] = currentDirective;\n    } else {\n      (parent as ChildPart | Directive).__directive = currentDirective;\n    }\n  }\n  if (currentDirective !== undefined) {\n    value = resolveDirective(\n      part,\n      currentDirective._$resolve(part, (value as DirectiveResult).values),\n      currentDirective,\n      attributeIndex\n    );\n  }\n  return value;\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n  /** @internal */\n  _$template: Template;\n  /** @internal */\n  _parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template, parent: ChildPart) {\n    this._$template = template;\n    this._$parent = parent;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions | undefined) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings,\n            this,\n            options\n          );\n        } else if (templatePart.type === ELEMENT_PART) {\n          part = new ElementPart(node as HTMLElement, this, options);\n        }\n        this._parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    return fragment;\n  }\n\n  _update(values: Array<unknown>) {\n    let i = 0;\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        if ((part as AttributePart).strings !== undefined) {\n          (part as AttributePart)._$setValue(values, part as AttributePart, i);\n          // The number of values the part consumes is part.strings.length - 1\n          // since values are in between template spans. We increment i by 1\n          // later in the loop, so increment it by part.strings.length - 2 here\n          i += (part as AttributePart).strings!.length - 2;\n        } else {\n          part._$setValue(values[i]);\n        }\n      }\n      i++;\n    }\n  }\n}\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  /** @internal */\n  readonly ctor: typeof AttributePart;\n  /** @internal */\n  readonly strings: ReadonlyArray<string>;\n};\ntype NodeTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | NodeTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part =\n  | ChildPart\n  | AttributePart\n  | PropertyPart\n  | BooleanAttributePart\n  | ElementPart\n  | EventPart;\n\nexport type {ChildPart};\nclass ChildPart {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions | undefined;\n  _$committedValue: unknown;\n  /** @internal */\n  __directive?: Directive;\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  private _textSanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  // The following fields will be patched onto ChildParts when required by\n  // AsyncDirective\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$setChildPartConnected?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number\n  ): void;\n  /** @internal */\n  _$reparentDisconnectables?(parent: Disconnectable): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this._$parent = parent;\n    this.options = options;\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      // Explicitly initialize for consistent class shape.\n      this._textSanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the connection state for any `AsyncDirectives` contained\n   * within this part and runs their `disconnected` or `reconnected`, according\n   * to the `isConnected` argument.\n   */\n  setConnected(isConnected: boolean) {\n    this._$setChildPartConnected?.(isConnected);\n  }\n\n  /**\n   * The parent node into which the part renders its content.\n   *\n   * A ChildPart's content consists of a range of adjacent child nodes of\n   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n   * `.endNode`).\n   *\n   * - If both `.startNode` and `.endNode` are non-null, then the part's content\n   * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n   *\n   * - If `.startNode` is non-null but `.endNode` is null, then the part's\n   * content consists of all siblings following `.startNode`, up to and\n   * including the last child of `.parentNode`. If `.endNode` is non-null, then\n   * `.startNode` will always be non-null.\n   *\n   * - If both `.endNode` and `.startNode` are null, then the part's content\n   * consists of all child nodes of `.parentNode`.\n   */\n  get parentNode(): Node {\n    return wrap(this._$startNode).parentNode!;\n  }\n\n  /**\n   * The part's leading marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get startNode(): Node | null {\n    return this._$startNode;\n  }\n\n  /**\n   * The part's trailing marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get endNode(): Node | null {\n    return this._$endNode;\n  }\n\n  _$setValue(value: unknown, directiveParent: DirectiveParent = this): void {\n    value = resolveDirective(this, value, directiveParent);\n    if (isPrimitive(value)) {\n      // Non-rendering child values. It's important that these do not render\n      // empty text nodes to avoid issues with preventing default <slot>\n      // fallback content.\n      if (value === nothing || value == null || value === '') {\n        if (this._$committedValue !== nothing) {\n          this._$clear();\n        }\n        this._$committedValue = nothing;\n      } else if (value !== this._$committedValue && value !== noChange) {\n        this._commitText(value);\n      }\n    } else if ((value as TemplateResult)._$litType$ !== undefined) {\n      this._commitTemplateResult(value as TemplateResult);\n    } else if ((value as Node).nodeType !== undefined) {\n      this._commitNode(value as Node);\n    } else if (isIterable(value)) {\n      this._commitIterable(value);\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert<T extends Node>(node: T, ref = this._$endNode) {\n    return wrap(wrap(this._$startNode).parentNode!).insertBefore(node, ref);\n  }\n\n  private _commitNode(value: Node): void {\n    if (this._$committedValue !== value) {\n      this._$clear();\n      if (\n        ENABLE_EXTRA_SECURITY_HOOKS &&\n        sanitizerFactoryInternal !== noopSanitizer\n      ) {\n        const parentNodeName = this._$startNode.parentNode?.nodeName;\n        if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n          this._insert(\n            new Text(\n              '/* lit-html will not write ' +\n                'TemplateResults to scripts and styles */'\n            )\n          );\n          return;\n        }\n      }\n      this._$committedValue = this._insert(value);\n    }\n  }\n\n  private _commitText(value: unknown): void {\n    const node = wrap(this._$startNode).nextSibling;\n    // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n    if (\n      node !== null &&\n      node.nodeType === 3 /* Node.TEXT_NODE */ &&\n      (this._$endNode === null\n        ? wrap(node).nextSibling === null\n        : node === wrap(this._$endNode).previousSibling)\n    ) {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(node, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n      }\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      (node as Text).data = value as string;\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        const textNode = document.createTextNode('');\n        this._commitNode(textNode);\n        // When setting text content, for security purposes it matters a lot\n        // what the parent is. For example, <style> and <script> need to be\n        // handled with care, while <span> does not. So first we need to put a\n        // text node into the document, then we can sanitize its contentx.\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n        textNode.data = value as string;\n      } else {\n        this._commitNode(d.createTextNode(value as string));\n      }\n    }\n    this._$committedValue = value;\n  }\n\n  private _commitTemplateResult(\n    result: TemplateResult | CompiledTemplateResult\n  ): void {\n    const {values, _$litType$} = result;\n    // If $litType$ is a number, result is a plain TemplateResult and we get\n    // the template from the template cache. If not, result is a\n    // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n    // to create the <template> element the first time we see it.\n    const template: Template | CompiledTemplate =\n      typeof _$litType$ === 'number'\n        ? this._$getTemplate(result as TemplateResult)\n        : (_$litType$.el === undefined &&\n            (_$litType$.el = Template.createElement(\n              _$litType$.h,\n              this.options\n            )),\n          _$litType$);\n\n    if ((this._$committedValue as TemplateInstance)?._$template === template) {\n      (this._$committedValue as TemplateInstance)._update(values);\n    } else {\n      const instance = new TemplateInstance(template as Template, this);\n      const fragment = instance._clone(this.options);\n      instance._update(values);\n      this._commitNode(fragment);\n      this._$committedValue = instance;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  /** @internal */\n  _$getTemplate(result: TemplateResult) {\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n      templateCache.set(result.strings, (template = new Template(result)));\n    }\n    return template;\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If value is an array, then the previous render was of an\n    // iterable and value will contain the ChildParts from the previous\n    // render. If value is not an array, clear this part and make a new\n    // array for ChildParts.\n    if (!isArray(this._$committedValue)) {\n      this._$committedValue = [];\n      this._$clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._$committedValue as ChildPart[];\n    let partIndex = 0;\n    let itemPart: ChildPart | undefined;\n\n    for (const item of value) {\n      if (partIndex === itemParts.length) {\n        // If no existing part, create a new one\n        // TODO (justinfagnani): test perf impact of always creating two parts\n        // instead of sharing parts between nodes\n        // https://github.com/lit/lit/issues/1266\n        itemParts.push(\n          (itemPart = new ChildPart(\n            this._insert(createMarker()),\n            this._insert(createMarker()),\n            this,\n            this.options\n          ))\n        );\n      } else {\n        // Reuse an existing part\n        itemPart = itemParts[partIndex];\n      }\n      itemPart._$setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // itemParts always have end nodes\n      this._$clear(\n        itemPart && wrap(itemPart._$endNode!).nextSibling,\n        partIndex\n      );\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n    }\n  }\n\n  /**\n   * Removes the nodes contained within this Part from the DOM.\n   *\n   * @param start Start node to clear from, for clearing a subset of the part's\n   *     DOM (used when truncating iterables)\n   * @param from  When `start` is specified, the index within the iterable from\n   *     which ChildParts are being removed, used for disconnecting directives in\n   *     those Parts.\n   *\n   * @internal\n   */\n  _$clear(\n    start: ChildNode | null = wrap(this._$startNode).nextSibling,\n    from?: number\n  ) {\n    this._$setChildPartConnected?.(false, true, from);\n    while (start && start !== this._$endNode) {\n      const n = wrap(start!).nextSibling;\n      (wrap(start!) as Element).remove();\n      start = n;\n    }\n  }\n}\n\nexport type {AttributePart};\nclass AttributePart {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = nothing;\n  /** @internal */\n  __directives?: Array<Directive | undefined>;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  protected _sanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(nothing);\n      this.strings = strings;\n    } else {\n      this._$committedValue = nothing;\n    }\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      this._sanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the value of this part by resolving the value from possibly multiple\n   * values and static strings and committing it to the DOM.\n   * If this part is single-valued, `this._strings` will be undefined, and the\n   * method will be called with a single value argument. If this part is\n   * multi-value, `this._strings` will be defined, and the method is called\n   * with the value array of the part's owning TemplateInstance, and an offset\n   * into the value array from which the values should be read.\n   * This method is overloaded this way to eliminate short-lived array slices\n   * of the template instance values, and allow a fast-path for single-valued\n   * parts.\n   *\n   * @param value The part value, or an array of values for multi-valued parts\n   * @param valueIndex the index to start reading values from. `undefined` for\n   *   single-valued parts\n   * @param noCommit causes the part to not commit its value to the DOM. Used\n   *   in hydration to prime attribute parts with their first-rendered value,\n   *   but not set the attribute, and in SSR to no-op the DOM operation and\n   *   capture the value for serialization.\n   *\n   * @internal\n   */\n  _$setValue(\n    value: unknown | Array<unknown>,\n    directiveParent: DirectiveParent = this,\n    valueIndex?: number,\n    noCommit?: boolean\n  ) {\n    const strings = this.strings;\n\n    // Whether any of the values has changed, for dirty-checking\n    let change = false;\n\n    if (strings === undefined) {\n      // Single-value binding case\n      value = resolveDirective(this, value, directiveParent, 0);\n      change =\n        !isPrimitive(value) ||\n        (value !== this._$committedValue && value !== noChange);\n      if (change) {\n        this._$committedValue = value;\n      }\n    } else {\n      // Interpolation case\n      const values = value as Array<unknown>;\n      value = strings[0];\n\n      let i, v;\n      for (i = 0; i < strings.length - 1; i++) {\n        v = resolveDirective(this, values[valueIndex! + i], directiveParent, i);\n\n        if (v === noChange) {\n          // If the user-provided value is `noChange`, use the previous value\n          v = (this._$committedValue as Array<unknown>)[i];\n        }\n        change ||=\n          !isPrimitive(v) || v !== (this._$committedValue as Array<unknown>)[i];\n        if (v === nothing) {\n          value = nothing;\n        } else if (value !== nothing) {\n          value += (v ?? '') + strings[i + 1];\n        }\n        // We always record each value, even if one is `nothing`, for future\n        // change detection.\n        (this._$committedValue as Array<unknown>)[i] = v;\n      }\n    }\n    if (change && !noCommit) {\n      this._commitValue(value);\n    }\n  }\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value === nothing) {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._sanitizer === undefined) {\n          this._sanitizer = sanitizerFactoryInternal(\n            this.element,\n            this.name,\n            'attribute'\n          );\n        }\n        value = this._sanitizer(value ?? '');\n      }\n      (wrap(this.element) as Element).setAttribute(\n        this.name,\n        (value ?? '') as string\n      );\n    }\n  }\n}\n\nexport type {PropertyPart};\nclass PropertyPart extends AttributePart {\n  readonly type = PROPERTY_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      if (this._sanitizer === undefined) {\n        this._sanitizer = sanitizerFactoryInternal(\n          this.element,\n          this.name,\n          'property'\n        );\n      }\n      value = this._sanitizer(value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.element as any)[this.name] = value === nothing ? undefined : value;\n  }\n}\n\nexport type {BooleanAttributePart};\nclass BooleanAttributePart extends AttributePart {\n  readonly type = BOOLEAN_ATTRIBUTE_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value && value !== nothing) {\n      (wrap(this.element) as Element).setAttribute(this.name, '');\n    } else {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    }\n  }\n}\n\ntype EventListenerWithOptions = EventListenerOrEventListenerObject &\n  Partial<AddEventListenerOptions>;\n\n/**\n * An AttributePart that manages an event listener via add/removeEventListener.\n *\n * This part works by adding itself as the event listener on an element, then\n * delegating to the value passed to it. This reduces the number of calls to\n * add/removeEventListener if the listener changes frequently, such as when an\n * inline function is used as a listener.\n *\n * Because event options are passed when adding listeners, we must take case\n * to add and remove the part as a listener when the event options change.\n */\nexport type {EventPart};\nclass EventPart extends AttributePart {\n  readonly type = EVENT_PART;\n\n  // EventPart does not use the base _$setValue/_resolveValue implementation\n  // since the dirty checking is more complex\n  /** @internal */\n  _$setValue(newListener: unknown, directiveParent: DirectiveParent = this) {\n    newListener =\n      resolveDirective(this, newListener, directiveParent, 0) ?? nothing;\n    if (newListener === noChange) {\n      return;\n    }\n    const oldListener = this._$committedValue;\n\n    // If the new value is nothing or any options change we have to remove the\n    // part as a listener.\n    const shouldRemoveListener =\n      (newListener === nothing && oldListener !== nothing) ||\n      (newListener as EventListenerWithOptions).capture !==\n        (oldListener as EventListenerWithOptions).capture ||\n      (newListener as EventListenerWithOptions).once !==\n        (oldListener as EventListenerWithOptions).once ||\n      (newListener as EventListenerWithOptions).passive !==\n        (oldListener as EventListenerWithOptions).passive;\n\n    // If the new value is not nothing and we removed the listener, we have\n    // to add the part as a listener.\n    const shouldAddListener =\n      newListener !== nothing &&\n      (oldListener === nothing || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n        this.name,\n        this,\n        oldListener as EventListenerWithOptions\n      );\n    }\n    if (shouldAddListener) {\n      // Beware: IE11 and Chrome 41 don't like using the listener as the\n      // options object. Figure out how to deal w/ this in IE11 - maybe\n      // patch addEventListener?\n      this.element.addEventListener(\n        this.name,\n        this,\n        newListener as EventListenerWithOptions\n      );\n    }\n    this._$committedValue = newListener;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this._$committedValue === 'function') {\n      // TODO (justinfagnani): do we need to default to this.element?\n      // It'll always be the same as `e.currentTarget`.\n      this._$committedValue.call(this.options?.host ?? this.element, event);\n    } else {\n      (this._$committedValue as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\nexport type {ElementPart};\nclass ElementPart {\n  readonly type = ELEMENT_PART;\n\n  /** @internal */\n  __directive?: Directive;\n\n  // This is to ensure that every Part has a _$committedValue\n  _$committedValue: undefined;\n\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  options: RenderOptions | undefined;\n\n  constructor(\n    public element: Element,\n    parent: Disconnectable,\n    options: RenderOptions | undefined\n  ) {\n    this._$parent = parent;\n    this.options = options;\n  }\n\n  _$setValue(value: unknown): void {\n    resolveDirective(this, value);\n  }\n}\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _\u03A3 object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _\u03A3 = {\n  // Used in lit-ssr\n  _boundAttributeSuffix: boundAttributeSuffix,\n  _marker: marker,\n  _markerMatch: markerMatch,\n  _HTML_RESULT: HTML_RESULT,\n  _getTemplateHtml: getTemplateHtml,\n  // Used in hydrate\n  _TemplateInstance: TemplateInstance,\n  _isIterable: isIterable,\n  _resolveDirective: resolveDirective,\n  // Used in tests and private-ssr-support\n  _ChildPart: ChildPart,\n  _AttributePart: AttributePart,\n  _BooleanAttributePart: BooleanAttributePart,\n  _EventPart: EventPart,\n  _PropertyPart: PropertyPart,\n  _ElementPart: ElementPart,\n};\n\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport']?.(Template, ChildPart);\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((globalThis as any)['litHtmlVersions'] ??= []).push('2.0.0-rc.3');\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * The main LitElement module, which defines the [[`LitElement`]] base class and\n * related APIs.\n *\n *  LitElement components can define a template and a set of observed\n * properties. Changing an observed property triggers a re-render of the\n * element.\n *\n *  Import [[`LitElement`]] and [[`html`]] from this module to create a\n * component:\n *\n *  ```js\n * import {LitElement, html} from 'lit-element';\n *\n * class MyElement extends LitElement {\n *\n *   // Declare observed properties\n *   static get properties() {\n *     return {\n *       adjective: {}\n *     }\n *   }\n *\n *   constructor() {\n *     this.adjective = 'awesome';\n *   }\n *\n *   // Define the element's template\n *   render() {\n *     return html`<p>your ${adjective} template here</p>`;\n *   }\n * }\n *\n * customElements.define('my-element', MyElement);\n * ```\n *\n * `LitElement` extends [[`ReactiveElement`]] and adds lit-html templating.\n * The `ReactiveElement` class is provided for users that want to build\n * their own custom element base classes that don't use lit-html.\n *\n * @packageDocumentation\n */\nimport {PropertyValues, ReactiveElement} from '@lit/reactive-element';\nimport {render, RenderOptions, noChange, ChildPart} from 'lit-html';\nexport * from '@lit/reactive-element';\nexport * from 'lit-html';\n\n// For backwards compatibility export ReactiveElement as UpdatingElement. Note,\n// IE transpilation requires exporting like this.\nexport const UpdatingElement = ReactiveElement;\n\nconst DEV_MODE = true;\n\ndeclare global {\n  interface Window {\n    litElementVersions: string[];\n  }\n}\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((globalThis as any)['litElementVersions'] ??= []).push('3.0.0-rc.2');\n\n/**\n * Base element class that manages element properties and attributes, and\n * renders a lit-html template.\n *\n * To define a component, subclass `LitElement` and implement a\n * `render` method to provide the component's template. Define properties\n * using the [[`properties`]] property or the [[`property`]] decorator.\n */\nexport class LitElement extends ReactiveElement {\n  /**\n   * Ensure this class is marked as `finalized` as an optimization ensuring\n   * it will not needlessly try to `finalize`.\n   *\n   * Note this property name is a string to prevent breaking Closure JS Compiler\n   * optimizations. See @lit/reactive-element for more information.\n   */\n  protected static ['finalized'] = true;\n\n  static _$litElement$ = true;\n\n  /**\n   * @category rendering\n   */\n  readonly renderOptions: RenderOptions = {host: this};\n\n  private __childPart: ChildPart | undefined = undefined;\n\n  /**\n   * @category rendering\n   */\n  protected createRenderRoot() {\n    const renderRoot = super.createRenderRoot();\n    // When adoptedStyleSheets are shimmed, they are inserted into the\n    // shadowRoot by createRenderRoot. Adjust the renderBefore node so that\n    // any styles in Lit content render before adoptedStyleSheets. This is\n    // important so that adoptedStyleSheets have precedence over styles in\n    // the shadowRoot.\n    this.renderOptions.renderBefore ??= renderRoot!.firstChild as ChildNode;\n    return renderRoot;\n  }\n\n  /**\n   * Updates the element. This method reflects property values to attributes\n   * and calls `render` to render DOM via lit-html. Setting properties inside\n   * this method will *not* trigger another update.\n   * @param changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected update(changedProperties: PropertyValues) {\n    // Setting properties in `render` should not trigger an update. Since\n    // updates are allowed after super.update, it's important to call `render`\n    // before that.\n    const value = this.render();\n    super.update(changedProperties);\n    this.__childPart = render(value, this.renderRoot, this.renderOptions);\n  }\n\n  // TODO(kschaaf): Consider debouncing directive disconnection so element moves\n  // do not thrash directive callbacks\n  // https://github.com/lit/lit/issues/1457\n  /**\n   * @category lifecycle\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.__childPart?.setConnected(true);\n  }\n\n  /**\n   * @category lifecycle\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__childPart?.setConnected(false);\n  }\n\n  /**\n   * Invoked on each update to perform rendering tasks. This method may return\n   * any value renderable by lit-html's `ChildPart` - typically a\n   * `TemplateResult`. Setting properties inside this method will *not* trigger\n   * the element to update.\n   * @category rendering\n   */\n  protected render(): unknown {\n    return noChange;\n  }\n}\n\n// Install hydration if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litElementHydrateSupport']?.({LitElement});\n\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litElementPlatformSupport']?.({LitElement});\n\n// DEV mode warnings\nif (DEV_MODE) {\n  // Note, for compatibility with closure compilation, this access\n  // needs to be as a string property index.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (LitElement as any)['finalize'] = function (this: typeof LitElement) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const finalized = (ReactiveElement as any).finalize.call(this);\n    if (!finalized) {\n      return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const warnRemoved = (obj: any, name: string) => {\n      if (obj[name] !== undefined) {\n        console.warn(\n          `\\`${name}\\` is implemented. It ` +\n            `has been removed from this version of LitElement. `\n          // TODO(sorvell): add link to changelog when location has stabilized.\n          // + See the changelog at https://github.com/lit/lit/blob/main/packages/lit-element/CHANGELOG.md`\n        );\n      }\n    };\n    [`render`, `getStyles`].forEach((name: string) =>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      warnRemoved(this as any, name)\n    );\n    [`adoptStyles`].forEach((name: string) =>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      warnRemoved(this.prototype as any, name)\n    );\n    return true;\n  };\n}\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _\u03A6 object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-html, since this module re-exports all of lit-html.\n *\n * @private\n */\nexport const _\u03A6 = {\n  _$attributeToProperty: (\n    el: LitElement,\n    name: string,\n    value: string | null\n  ) => {\n    // eslint-disable-next-line\n    (el as any)._$attributeToProperty(name, value);\n  },\n  // eslint-disable-next-line\n  _$changedProperties: (el: LitElement) => (el as any)._$changedProperties,\n};\n", "import {css} from 'lit';export default css`:host {\n  display: block;\n  position: relative;\n  border-radius: 6px;\n  background: var(--code-button-background, transparent);\n  overflow: hidden;\n}\n\nbutton {\n  color: inherit;\n  position: relative;\n  padding: 9px 16px;\n  border: none;\n  cursor: pointer;\n  display: block;\n  font-size: 16px;\n  background: var(--code-button, hsla(0 100% 100% / 0.9));\n  outline: none;\n  transition: color, background 0.1s ease;\n}\n\nbutton:focus,\nbutton:hover {\n  color: var(--code-button-focus-color, hsla(0 100% 100% / 0.75));\n  background: var(--code-button-focus-background, hsla(0 100% 0% / 0.75));\n}\n\nbutton[selected] {\n  text-decoration: none;\n}\n`", "import {css} from 'lit';export default css`img {\n  height: var(--code-tabs-icon-height, 24px);\n  width: auto;\n}\n\n#tabs {\n  display: flex;\n  background: var(--code-tabs-background, hsla(0 100% 100% / 0.9));\n  overflow-x: auto;\n  justify-content: var(--code-tabs-justify-tabs, start);\n}\n\n#tabs button {\n  display: flex;\n  align-items: center;\n  gap: 9px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n}\n\n#tabs button[selected] {\n  background: var(--markdown-syntax-background-color, #f6f8fa);\n}\n\n#tabs button[selected]:focus,\n#tabs button[selected]:hover {\n  color: inherit;\n}\n\n#tabs button[selected]::before {\n  content: '',;\n  z-index: -1,;\n  position: absolute;\n  left: -100%;\n  border-bottom-right-radius: 3px;\n  background-color: var(--markdown-syntax-background-color, #f6f8fa);\n}\n\n#tabpanel {\n  background-color: var(--code-tabs-background-color, var(--markdown-syntax-background-color));\n  border-radius: 3px;\n  min-height: var(--code-tabs-min-height, 1px);\n}\n\n:host([selected-index=\"0\"]) #tabpanel {\n  border-top-left-radius: 0;\n}\n`", "import {css} from 'lit';export default css`:host(:not([selected])) {\n  display: none;\n}\n\n:host([selected]) {\n  display: block;\n}\n\ncode-copy {\n  display: flex;\n  flex: 1;\n}\n`", "import { SelectMixin } from '@pwrs/mixins/select/select-mixin';\nimport { html, LitElement, PropertyValues, TemplateResult } from 'lit';\nimport { customElement, property, queryAll, state } from 'lit/decorators.js';\n\nimport ButtonStyles from './button.css';\nimport TabsStyles from './tabs.css';\nimport TabStyles from './tab.css';\n\ndeclare module '@pwrs/mixins/select/select-mixin' {\n  export interface Item {\n    dataset: DOMStringMap & Tab;\n  }\n}\n\nexport interface Tab {\n  id: string;\n  label: string;\n  iconHref?: string;\n  iconTemplate?: string;\n  synonyms?: string[];\n}\n\nconst INSTANCES = new Set<CodeTabs>();\n\n@customElement('code-tabs')\nexport class CodeTabs extends SelectMixin(LitElement) {\n  static readonly allowedChildren = ['code-tab'];\n\n  static readonly styles = [ButtonStyles, TabsStyles];\n\n  @state() labels = new Map<string, Tab>();\n\n  @queryAll('[role=\"tab\"]') tabs: NodeListOf<HTMLButtonElement>;\n\n  @property({ attribute: 'default-tab' }) defaultTab: string;\n\n  @property() collection: string;\n\n  constructor() {\n    super();\n    this.onClickTab = this.onClickTab.bind(this);\n  }\n\n  protected initialSelectedIndex = 0;\n\n  connectedCallback(): void {\n    super.connectedCallback();\n    this.setAttribute('role', 'tablist');\n    this.initialSelectedIndex = parseInt(this.getAttribute('selected-index'));\n    if (this.collection)\n      this.initCollection();\n  }\n\n  disconnectedCallback(): void {\n    super.disconnectedCallback?.();\n    INSTANCES.delete(this);\n  }\n\n  async firstUpdated(changed: PropertyValues<this>): Promise<void> {\n    this.initLabels();\n    super.firstUpdated(changed);\n    this.selectIndex(await this.getInitialSelectedIndex());\n    this.onSelect();\n  }\n\n  updated(changed: PropertyValues<this>): void {\n    super.updated(changed);\n    if (changed.has('collection'))\n      this.initCollection();\n  }\n\n  protected async getInitialSelectedIndex(): Promise<number> {\n    if (this.querySelector('[slot=default]')) return -1;\n    await this.updateComplete;\n    const stored = localStorage.getItem(`code-tabs-selected-${this.collection}`);\n    const index =\n        stored ? this.items.findIndex(x => x.dataset.id === stored)\n      : this.defaultTab ? this.items.findIndex(x => x.dataset.id === this.defaultTab)\n      : this.initialSelectedIndex;\n    return index < 0 ? this.initialSelectedIndex : index;\n  }\n\n  private initCollection() {\n    if (this.collection)\n      INSTANCES.add(this);\n    else\n      INSTANCES.delete(this);\n  }\n\n  render(): TemplateResult {\n    const items = this.items ?? [];\n    return html`\n      <div id=\"tabs\" role=\"tablist\">\n        ${items.map(({ dataset: { id, iconHref, label } }, i) => html`\n        <button role=\"tab\" data-id=\"${id}\" @click=\"${this.onClickTab}\" ?selected=\"${this.selectedIndex === i}\">\n          <img .src=\"${iconHref}\" role=\"presentation\"/>\n          ${label}\n        </button>\n        `)}\n      </div>\n\n      <div id=\"tabpanel\" role=\"tabpanel\">\n        <slot></slot>\n        <div id=\"default\" ?hidden=\"${this.selectedItem}\">\n          <slot name=\"default\"></slot>\n        </div>\n      </div>\n    `;\n  }\n\n  public selectId(idToSelect: string): void {\n    const synonyms = this.getLabel(idToSelect)?.synonyms ?? [];\n    const index =\n      this.items.findIndex(({ dataset: { id } }) => id === idToSelect || synonyms.includes(id));\n    if (index >= 0 && this.selectedIndex !== index)\n      this.selectIndex(index);\n  }\n\n  onSelect(): void {\n    for (const tab of this.tabs)\n      tab.removeAttribute('selected');\n    const tab = this.tabs[this.selectedIndex as number];\n    if (!tab) return;\n    tab.setAttribute('selected', '');\n    const { left } = tab.getBoundingClientRect();\n    this.shadowRoot.getElementById('tabs')\n      .scrollTo({ behavior: 'smooth', left });\n  }\n\n  private onClickTab(event: Event & { target: HTMLButtonElement }) {\n    const tabs = [...this.tabs];\n    let tab = event.target;\n    while (!tabs.includes(tab))\n      tab = tab.parentElement as HTMLButtonElement;\n    const index = [...this.tabs].indexOf(tab);\n    this.selectIndex(index);\n    if (this.collection) {\n      const [{ dataset: { id = this.defaultTab } }] = [this.selectedItem].flat();\n      localStorage.setItem(`code-tabs-selected-${this.collection}`, id);\n      INSTANCES.forEach(x => x.selectId(id));\n    }\n    this.fire('tab-selected', event.target);\n  }\n\n  private getLabel(tag: string) {\n    return this.labels.get(tag) ?? null;\n  }\n\n  protected initLabels(event?: Event): void {\n    if (event) this.labels.clear();\n    this.items\n      .forEach(({ dataset: { id, label, iconHref, ...dataset } }: HTMLElement) => {\n        const synonyms = (dataset.synonyms ?? '')\n          .split(',')\n          .map(x => x.trim());\n\n        const pkg: Tab = { id, label, iconHref, synonyms };\n\n        this.labels.set(pkg.id, pkg);\n        for (const synonym of synonyms)\n          this.labels.set(synonym, pkg);\n      });\n  }\n}\n\n@customElement('code-tab')\nexport class CodeTab extends LitElement {\n  static readonly styles = [TabStyles];\n\n  @property() tab: string;\n\n  @property({ type: Boolean, attribute: 'no-copy' }) noCopy = false;\n\n  render(): TemplateResult {\n    if (this.noCopy) {\n      return html`\n        <slot></slot>\n      `;\n    } else {\n      return html`\n        <code-copy>\n          <slot></slot>\n        </code-copy>\n      `;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
